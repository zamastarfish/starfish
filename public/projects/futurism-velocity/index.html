<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>futurism â€” velocity</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; height: 100%; overflow: hidden; background: #0a0a0a; }
    canvas { display: block; }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
</head>
<body>
  <script>
    // Futurism Velocity: Speed and motion
    // Celebrating the beauty of movement
    
    const FUTURISM = {
      orange: '#FF6B35',
      yellow: '#FFD23F',
      cyan: '#00D9FF',
      magenta: '#FF00AA',
      white: '#FFFFFF',
      dark: '#0A0A0A'
    };
    
    let movers = [];
    let trails = [];
    
    function setup() {
      createCanvas(windowWidth, windowHeight);
      
      // Create fast-moving objects
      for (let i = 0; i < 8; i++) {
        movers.push(new Mover());
      }
    }
    
    function draw() {
      // Motion blur effect
      fill(10, 10, 10, 30);
      rect(0, 0, width, height);
      
      // Speed lines (background)
      drawSpeedLines();
      
      // Update and draw movers
      for (let mover of movers) {
        mover.update();
        mover.draw();
      }
      
      // Draw motion trails
      for (let i = trails.length - 1; i >= 0; i--) {
        trails[i].update();
        trails[i].draw();
        if (trails[i].isDead()) {
          trails.splice(i, 1);
        }
      }
    }
    
    function drawSpeedLines() {
      // Diagonal speed lines suggesting velocity
      stroke(255, 8);
      strokeWeight(1);
      
      const angle = -PI / 6;
      const spacing = 30;
      
      for (let i = 0; i < width + height; i += spacing) {
        const x1 = i;
        const y1 = 0;
        const len = random(50, 200);
        const x2 = x1 + cos(angle) * len;
        const y2 = y1 + sin(angle) * len;
        line(x1, y1, x2, y2);
      }
    }
    
    class Mover {
      constructor() {
        this.reset();
      }
      
      reset() {
        // Start from left, move right
        this.pos = createVector(-100, random(height * 0.2, height * 0.8));
        this.vel = createVector(random(8, 20), random(-2, 2));
        this.acc = createVector(random(0.1, 0.3), 0);
        
        this.size = random(20, 60);
        this.color = random([FUTURISM.orange, FUTURISM.yellow, FUTURISM.cyan, FUTURISM.magenta]);
        this.shape = random(['rect', 'triangle', 'circle']);
        this.rotation = 0;
        this.rotSpeed = random(-0.1, 0.1);
        
        this.history = [];
        this.maxHistory = 15;
      }
      
      update() {
        // Store position history for trails
        this.history.push(this.pos.copy());
        if (this.history.length > this.maxHistory) {
          this.history.shift();
        }
        
        this.vel.add(this.acc);
        this.vel.limit(25);
        this.pos.add(this.vel);
        this.rotation += this.rotSpeed;
        
        // Spawn trail particles
        if (random() < 0.5) {
          trails.push(new Trail(this.pos.x, this.pos.y, this.color, this.vel.copy()));
        }
        
        // Reset when off screen
        if (this.pos.x > width + 100) {
          this.reset();
        }
      }
      
      draw() {
        // Motion trail (position history)
        noFill();
        strokeWeight(2);
        
        for (let i = 0; i < this.history.length; i++) {
          const alpha = map(i, 0, this.history.length, 0, 150);
          const size = map(i, 0, this.history.length, this.size * 0.3, this.size);
          stroke(red(color(this.color)), green(color(this.color)), blue(color(this.color)), alpha);
          
          push();
          translate(this.history[i].x, this.history[i].y);
          rotate(this.rotation * (i / this.history.length));
          
          if (this.shape === 'rect') {
            rectMode(CENTER);
            rect(0, 0, size, size * 0.6);
          } else if (this.shape === 'triangle') {
            triangle(0, -size/2, -size/2, size/2, size/2, size/2);
          } else {
            ellipse(0, 0, size * 0.8, size * 0.8);
          }
          pop();
        }
        
        // Main shape
        push();
        translate(this.pos.x, this.pos.y);
        rotate(this.rotation);
        
        fill(this.color);
        noStroke();
        
        if (this.shape === 'rect') {
          rectMode(CENTER);
          rect(0, 0, this.size, this.size * 0.6);
        } else if (this.shape === 'triangle') {
          triangle(0, -this.size/2, -this.size/2, this.size/2, this.size/2, this.size/2);
        } else {
          ellipse(0, 0, this.size * 0.8, this.size * 0.8);
        }
        
        // Speed highlight
        fill(255, 200);
        ellipse(-this.size * 0.2, -this.size * 0.1, this.size * 0.15, this.size * 0.15);
        
        pop();
      }
    }
    
    class Trail {
      constructor(x, y, col, vel) {
        this.pos = createVector(x + random(-5, 5), y + random(-5, 5));
        this.vel = vel.copy().mult(-0.3).add(createVector(random(-1, 1), random(-1, 1)));
        this.color = col;
        this.life = 1;
        this.decay = random(0.02, 0.05);
        this.size = random(2, 8);
      }
      
      update() {
        this.pos.add(this.vel);
        this.vel.mult(0.95);
        this.life -= this.decay;
      }
      
      draw() {
        noStroke();
        fill(red(color(this.color)), green(color(this.color)), blue(color(this.color)), this.life * 150);
        ellipse(this.pos.x, this.pos.y, this.size * this.life);
      }
      
      isDead() {
        return this.life <= 0;
      }
    }
    
    function windowResized() {
      resizeCanvas(windowWidth, windowHeight);
    }
  </script>
</body>
</html>
