<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Flocking — zama.starfish</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      background: #0a0a0f; 
      overflow: hidden;
      min-height: 100vh;
    }
    canvas { 
      display: block;
      cursor: none;
    }
    #info {
      position: fixed;
      bottom: 20px;
      left: 20px;
      color: rgba(255,255,255,0.3);
      font-family: monospace;
      font-size: 12px;
    }
    #info a { color: rgba(255,255,255,0.5); }
  .back-btn { position: fixed; top: 20px; left: 20px; color: rgba(255,255,255,0.4); text-decoration: none; font-size: 24px; z-index: 1000; transition: color 0.2s; line-height: 1; } .back-btn:hover { color: rgba(255,255,255,0.8); }
  </style>
</head>
<body>
  <a href="/" class="back-btn">←</a>
  <canvas id="canvas"></canvas>
  <div id="info">
    flocking — <a href="https://starfish.zama.space">zama.starfish</a>
  </div>
  
  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    let width, height;
    let boids = [];
    let mouseX = -1000, mouseY = -1000;
    let mouseActive = false;
    
    const CONFIG = {
      boidCount: 300,
      maxSpeed: 4,
      maxForce: 0.15,
      perceptionRadius: 50,
      separationRadius: 25,
      // Weights
      separationWeight: 1.8,
      alignmentWeight: 1.0,
      cohesionWeight: 1.0,
      // Predator
      predatorRadius: 150,
      predatorForce: 0.5,
      // Visual
      boidSize: 8,
      trailAlpha: 0.08
    };
    
    class Vector {
      constructor(x = 0, y = 0) {
        this.x = x;
        this.y = y;
      }
      
      add(v) { this.x += v.x; this.y += v.y; return this; }
      sub(v) { this.x -= v.x; this.y -= v.y; return this; }
      mult(n) { this.x *= n; this.y *= n; return this; }
      div(n) { if (n !== 0) { this.x /= n; this.y /= n; } return this; }
      
      mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
      
      setMag(n) {
        const m = this.mag();
        if (m !== 0) { this.x = this.x / m * n; this.y = this.y / m * n; }
        return this;
      }
      
      limit(max) {
        if (this.mag() > max) this.setMag(max);
        return this;
      }
      
      copy() { return new Vector(this.x, this.y); }
      
      static sub(a, b) { return new Vector(a.x - b.x, a.y - b.y); }
      static dist(a, b) { return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2); }
    }
    
    class Boid {
      constructor() {
        this.pos = new Vector(Math.random() * width, Math.random() * height);
        this.vel = new Vector(Math.random() * 2 - 1, Math.random() * 2 - 1);
        this.vel.setMag(CONFIG.maxSpeed * 0.5);
        this.acc = new Vector();
        
        // Slight color variation
        const hue = 200 + Math.random() * 40;
        const light = 60 + Math.random() * 20;
        this.color = `hsl(${hue}, 50%, ${light}%)`;
        this.size = CONFIG.boidSize * (0.7 + Math.random() * 0.6);
      }
      
      edges() {
        const margin = 50;
        const turnForce = 0.5;
        
        if (this.pos.x < margin) this.acc.x += turnForce;
        if (this.pos.x > width - margin) this.acc.x -= turnForce;
        if (this.pos.y < margin) this.acc.y += turnForce;
        if (this.pos.y > height - margin) this.acc.y -= turnForce;
      }
      
      flock(boids) {
        let separation = new Vector();
        let alignment = new Vector();
        let cohesion = new Vector();
        let sepCount = 0;
        let alignCount = 0;
        let cohCount = 0;
        
        for (const other of boids) {
          if (other === this) continue;
          
          const d = Vector.dist(this.pos, other.pos);
          
          // Separation
          if (d < CONFIG.separationRadius && d > 0) {
            const diff = Vector.sub(this.pos, other.pos);
            diff.div(d * d); // Weight by distance
            separation.add(diff);
            sepCount++;
          }
          
          // Alignment & Cohesion
          if (d < CONFIG.perceptionRadius) {
            alignment.add(other.vel);
            cohesion.add(other.pos);
            alignCount++;
            cohCount++;
          }
        }
        
        // Separation
        if (sepCount > 0) {
          separation.div(sepCount);
          separation.setMag(CONFIG.maxSpeed);
          separation.sub(this.vel);
          separation.limit(CONFIG.maxForce);
          separation.mult(CONFIG.separationWeight);
        }
        
        // Alignment
        if (alignCount > 0) {
          alignment.div(alignCount);
          alignment.setMag(CONFIG.maxSpeed);
          alignment.sub(this.vel);
          alignment.limit(CONFIG.maxForce);
          alignment.mult(CONFIG.alignmentWeight);
        }
        
        // Cohesion
        if (cohCount > 0) {
          cohesion.div(cohCount);
          cohesion.sub(this.pos);
          cohesion.setMag(CONFIG.maxSpeed);
          cohesion.sub(this.vel);
          cohesion.limit(CONFIG.maxForce);
          cohesion.mult(CONFIG.cohesionWeight);
        }
        
        this.acc.add(separation);
        this.acc.add(alignment);
        this.acc.add(cohesion);
      }
      
      flee(predatorX, predatorY) {
        const d = Math.sqrt((this.pos.x - predatorX) ** 2 + (this.pos.y - predatorY) ** 2);
        
        if (d < CONFIG.predatorRadius) {
          const flee = new Vector(this.pos.x - predatorX, this.pos.y - predatorY);
          flee.setMag(CONFIG.maxSpeed * 2);
          flee.sub(this.vel);
          flee.limit(CONFIG.maxForce * 3);
          
          // Stronger when closer
          const strength = 1 - (d / CONFIG.predatorRadius);
          flee.mult(CONFIG.predatorForce * strength * 10);
          
          this.acc.add(flee);
        }
      }
      
      update() {
        this.vel.add(this.acc);
        this.vel.limit(CONFIG.maxSpeed);
        this.pos.add(this.vel);
        this.acc.mult(0);
      }
      
      draw() {
        const angle = Math.atan2(this.vel.y, this.vel.x);
        
        ctx.save();
        ctx.translate(this.pos.x, this.pos.y);
        ctx.rotate(angle);
        
        // Bird shape
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.moveTo(this.size, 0);
        ctx.lineTo(-this.size * 0.5, -this.size * 0.4);
        ctx.lineTo(-this.size * 0.3, 0);
        ctx.lineTo(-this.size * 0.5, this.size * 0.4);
        ctx.closePath();
        ctx.fill();
        
        ctx.restore();
      }
    }
    
    function resize() {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
    }
    
    function init() {
      boids = [];
      for (let i = 0; i < CONFIG.boidCount; i++) {
        boids.push(new Boid());
      }
    }
    
    function drawPredator() {
      if (!mouseActive) return;
      
      // Hawk silhouette
      ctx.save();
      ctx.translate(mouseX, mouseY);
      
      // Glow
      const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 30);
      gradient.addColorStop(0, 'rgba(255, 100, 100, 0.3)');
      gradient.addColorStop(1, 'rgba(255, 100, 100, 0)');
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(0, 0, 30, 0, Math.PI * 2);
      ctx.fill();
      
      // Body
      ctx.fillStyle = 'rgba(200, 80, 80, 0.8)';
      ctx.beginPath();
      ctx.moveTo(15, 0);
      ctx.lineTo(-10, -8);
      ctx.lineTo(-5, 0);
      ctx.lineTo(-10, 8);
      ctx.closePath();
      ctx.fill();
      
      ctx.restore();
    }
    
    function animate() {
      // Fade trail
      ctx.fillStyle = `rgba(10, 10, 15, ${CONFIG.trailAlpha})`;
      ctx.fillRect(0, 0, width, height);
      
      // Update and draw boids
      for (const boid of boids) {
        boid.edges();
        boid.flock(boids);
        if (mouseActive) {
          boid.flee(mouseX, mouseY);
        }
        boid.update();
        boid.draw();
      }
      
      drawPredator();
      
      requestAnimationFrame(animate);
    }
    
    // Events
    window.addEventListener('resize', resize);
    
    canvas.addEventListener('mousemove', (e) => {
      mouseX = e.clientX;
      mouseY = e.clientY;
      mouseActive = true;
    });
    
    canvas.addEventListener('mouseleave', () => {
      mouseActive = false;
    });
    
    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      mouseX = e.touches[0].clientX;
      mouseY = e.touches[0].clientY;
      mouseActive = true;
    }, { passive: false });
    
    canvas.addEventListener('touchend', () => {
      mouseActive = false;
    });
    
    // Init
    resize();
    init();
    animate();
  </script>
</body>
</html>
