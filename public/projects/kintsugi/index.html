<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Kintsugi</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #1a1918;
      touch-action: none;
    }
    canvas {
      display: block;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  
  <script>
    // ========================================
    // KINTSUGI - 金継ぎ
    // Phase 1: Physical Presence
    // ========================================
    
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    let size, centerX, centerY, bowlRadius;
    
    function resize() {
      const minDim = Math.min(window.innerWidth, window.innerHeight);
      size = Math.min(minDim * 0.95, 650);
      canvas.width = size;
      canvas.height = size;
      centerX = size / 2;
      centerY = size / 2;
      bowlRadius = size * 0.36;
    }
    
    // ========================================
    // COLORS
    // ========================================
    
    const COLORS = {
      bg: '#1a1918',
      ceramic: '#ebe7e2',
      ceramicMid: '#d8d4ce',
      ceramicShadow: '#c4bfb8',
      ceramicDark: '#a8a39c',
      ceramicEdge: '#f5f2ef',
      rawEdge: '#d0ccc6',
      gold: '#d4a847',
      goldBright: '#ffe566',
      goldMid: '#c9973d',
      goldDark: '#8b6914',
      goldGlow: 'rgba(255, 210, 80, 0.5)',
    };
    
    // ========================================
    // STATE
    // ========================================
    
    let state = 'whole';
    let holdTime = 0;
    let holdStart = 0;
    let isHolding = false;
    let stateTimer = 0;
    let breakPoint = { x: centerX, y: centerY };
    
    let fragments = [];
    let goldSeams = [];
    let dustParticles = [];
    let goldParticles = [];
    let breakCount = 0;
    let isHovering = false;
    let breathPhase = 0;
    
    // ========================================
    // VORONOI FRAGMENTATION
    // ========================================
    
    function generateSeedPoints(count, cx, cy, radius, impactX, impactY) {
      const points = [];
      
      // Bias points toward impact location
      for (let i = 0; i < count; i++) {
        let x, y;
        
        if (i < count * 0.4) {
          // Some points near impact
          const angle = Math.random() * Math.PI * 2;
          const r = Math.random() * radius * 0.5;
          x = impactX + Math.cos(angle) * r;
          y = impactY + Math.sin(angle) * r;
        } else {
          // Rest distributed across bowl
          const angle = Math.random() * Math.PI * 2;
          const r = Math.sqrt(Math.random()) * radius * 0.9;
          x = cx + Math.cos(angle) * r;
          y = cy + Math.sin(angle) * r;
        }
        
        // Keep within bowl
        const dist = Math.hypot(x - cx, y - cy);
        if (dist > radius * 0.95) {
          const angle = Math.atan2(y - cy, x - cx);
          x = cx + Math.cos(angle) * radius * 0.9;
          y = cy + Math.sin(angle) * radius * 0.9;
        }
        
        points.push({ x, y, id: i });
      }
      
      return points;
    }
    
    function getVoronoiCell(point, allPoints, cx, cy, radius) {
      const resolution = 64;
      let cellPoints = [];
      
      // Start with circle around point
      for (let i = 0; i < resolution; i++) {
        const angle = (i / resolution) * Math.PI * 2;
        cellPoints.push({
          x: point.x + Math.cos(angle) * radius * 2,
          y: point.y + Math.sin(angle) * radius * 2
        });
      }
      
      // Clip to bowl
      cellPoints = clipToCircle(cellPoints, cx, cy, radius);
      if (cellPoints.length < 3) return [];
      
      // Clip by each bisector
      for (const other of allPoints) {
        if (other.id === point.id) continue;
        
        const midX = (point.x + other.x) / 2;
        const midY = (point.y + other.y) / 2;
        const nx = -(other.y - point.y);
        const ny = other.x - point.x;
        
        cellPoints = clipByLine(cellPoints, midX, midY, nx, ny);
        if (cellPoints.length < 3) return [];
      }
      
      return cellPoints;
    }
    
    function clipToCircle(poly, cx, cy, r) {
      const result = [];
      for (let i = 0; i < poly.length; i++) {
        const curr = poly[i];
        const next = poly[(i + 1) % poly.length];
        const currIn = Math.hypot(curr.x - cx, curr.y - cy) <= r;
        const nextIn = Math.hypot(next.x - cx, next.y - cy) <= r;
        
        if (currIn) result.push(curr);
        
        if (currIn !== nextIn) {
          const inter = lineCircleIntersect(curr, next, cx, cy, r);
          if (inter) result.push(inter);
        }
      }
      return result;
    }
    
    function lineCircleIntersect(p1, p2, cx, cy, r) {
      const dx = p2.x - p1.x, dy = p2.y - p1.y;
      const fx = p1.x - cx, fy = p1.y - cy;
      const a = dx*dx + dy*dy;
      const b = 2*(fx*dx + fy*dy);
      const c = fx*fx + fy*fy - r*r;
      const disc = b*b - 4*a*c;
      if (disc < 0) return null;
      let t = (-b - Math.sqrt(disc)) / (2*a);
      if (t < 0 || t > 1) t = (-b + Math.sqrt(disc)) / (2*a);
      if (t < 0 || t > 1) return null;
      return { x: p1.x + t*dx, y: p1.y + t*dy };
    }
    
    function clipByLine(poly, px, py, nx, ny) {
      const result = [];
      for (let i = 0; i < poly.length; i++) {
        const curr = poly[i];
        const next = poly[(i + 1) % poly.length];
        const currSide = (curr.x - px)*nx + (curr.y - py)*ny;
        const nextSide = (next.x - px)*nx + (next.y - py)*ny;
        
        if (currSide >= 0) result.push(curr);
        
        if ((currSide >= 0) !== (nextSide >= 0)) {
          const t = currSide / (currSide - nextSide);
          result.push({
            x: curr.x + t*(next.x - curr.x),
            y: curr.y + t*(next.y - curr.y)
          });
        }
      }
      return result;
    }
    
    function createFragments(intensity, impactX, impactY) {
      const numPoints = Math.floor(7 + intensity * 11);
      const seeds = generateSeedPoints(numPoints, centerX, centerY, bowlRadius, impactX, impactY);
      
      fragments = [];
      const newSeams = [];
      
      for (const seed of seeds) {
        const verts = getVoronoiCell(seed, seeds, centerX, centerY, bowlRadius);
        if (verts.length < 3) continue;
        
        // Centroid
        let cx = 0, cy = 0;
        for (const v of verts) { cx += v.x; cy += v.y; }
        cx /= verts.length; cy /= verts.length;
        
        // Distance from impact affects velocity
        const impactDist = Math.hypot(cx - impactX, cy - impactY);
        const impactInfluence = Math.max(0, 1 - impactDist / (bowlRadius * 1.5));
        
        const angle = Math.atan2(cy - impactY, cx - impactX);
        const speed = (2 + Math.random() * 5) * intensity * (0.5 + impactInfluence);
        
        // Fragment thickness (for 3D effect)
        const thickness = 8 + Math.random() * 6;
        
        fragments.push({
          vertices: verts.map(v => ({ x: v.x - cx, y: v.y - cy })),
          x: cx, y: cy,
          originX: cx, originY: cy,
          vx: Math.cos(angle + (Math.random()-0.5)*0.6) * speed,
          vy: Math.sin(angle + (Math.random()-0.5)*0.6) * speed - 3 * intensity,
          rotation: 0,
          rotationVel: (Math.random()-0.5) * 0.12 * intensity,
          thickness: thickness,
          tilt: (Math.random()-0.5) * 0.3 // 3D tilt
        });
        
        // Seams
        for (let i = 0; i < verts.length; i++) {
          const v1 = verts[i], v2 = verts[(i+1) % verts.length];
          const mid = { x: (v1.x+v2.x)/2, y: (v1.y+v2.y)/2 };
          if (Math.hypot(mid.x - centerX, mid.y - centerY) < bowlRadius - 3) {
            newSeams.push({
              x1: v1.x, y1: v1.y, x2: v2.x, y2: v2.y,
              progress: 0, flowProgress: 0
            });
          }
        }
      }
      
      fragments.newSeams = newSeams;
      
      // Create dust particles
      createDustBurst(impactX, impactY, intensity);
    }
    
    // ========================================
    // PARTICLES
    // ========================================
    
    function createDustBurst(x, y, intensity) {
      const count = Math.floor(30 + intensity * 50);
      
      for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = (1 + Math.random() * 4) * intensity;
        const size = 1 + Math.random() * 3;
        
        dustParticles.push({
          x, y,
          vx: Math.cos(angle) * speed + (Math.random()-0.5) * 2,
          vy: Math.sin(angle) * speed - Math.random() * 3,
          size,
          life: 1,
          decay: 0.015 + Math.random() * 0.02,
          gravity: 0.05 + Math.random() * 0.05
        });
      }
    }
    
    function createGoldSparkle(x, y) {
      goldParticles.push({
        x: x + (Math.random()-0.5) * 10,
        y: y + (Math.random()-0.5) * 10,
        vx: (Math.random()-0.5) * 0.5,
        vy: (Math.random()-0.5) * 0.5 - 0.3,
        size: 1 + Math.random() * 2,
        life: 1,
        decay: 0.02 + Math.random() * 0.02
      });
    }
    
    function updateParticles() {
      // Dust
      for (let i = dustParticles.length - 1; i >= 0; i--) {
        const p = dustParticles[i];
        p.vy += p.gravity;
        p.x += p.vx;
        p.y += p.vy;
        p.vx *= 0.98;
        p.vy *= 0.98;
        p.life -= p.decay;
        if (p.life <= 0) dustParticles.splice(i, 1);
      }
      
      // Gold sparkles
      for (let i = goldParticles.length - 1; i >= 0; i--) {
        const p = goldParticles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life -= p.decay;
        if (p.life <= 0) goldParticles.splice(i, 1);
      }
    }
    
    function drawParticles() {
      // Dust
      for (const p of dustParticles) {
        ctx.globalAlpha = p.life * 0.6;
        ctx.fillStyle = COLORS.rawEdge;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Gold sparkles - more magical
      for (const p of goldParticles) {
        const alpha = p.life * p.life; // Fade out faster at end
        ctx.globalAlpha = alpha;
        
        // Outer glow
        ctx.fillStyle = 'rgba(255, 200, 80, 0.4)';
        ctx.shadowColor = 'rgba(255, 200, 100, 0.8)';
        ctx.shadowBlur = 15;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size * 2, 0, Math.PI * 2);
        ctx.fill();
        
        // Bright core
        ctx.shadowBlur = 8;
        ctx.fillStyle = COLORS.goldBright;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
        
        // White hot center
        ctx.shadowBlur = 0;
        ctx.fillStyle = 'rgba(255, 255, 240, 0.9)';
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size * 0.4, 0, Math.PI * 2);
        ctx.fill();
      }
      
      ctx.globalAlpha = 1;
    }
    
    // ========================================
    // PHYSICS
    // ========================================
    
    function updatePhysics() {
      const gravity = 0.18;
      const friction = 0.982;
      const bounce = 0.25;
      const boundary = bowlRadius * 2.2;
      
      let settled = true;
      
      for (const f of fragments) {
        f.vy += gravity;
        f.x += f.vx;
        f.y += f.vy;
        f.vx *= friction;
        f.vy *= friction;
        f.rotation += f.rotationVel;
        f.rotationVel *= 0.97;
        
        // Ground
        if (f.y > centerY + boundary) {
          f.y = centerY + boundary;
          f.vy *= -bounce;
          f.vx *= 0.8;
          f.rotationVel *= 0.5;
        }
        
        // Walls
        if (f.x < centerX - boundary) { f.x = centerX - boundary; f.vx *= -bounce; }
        if (f.x > centerX + boundary) { f.x = centerX + boundary; f.vx *= -bounce; }
        
        if (Math.abs(f.vx) > 0.15 || Math.abs(f.vy) > 0.15) settled = false;
      }
      
      return settled;
    }
    
    function updateMending(progress) {
      const eased = easeInOutQuart(progress);
      
      for (const f of fragments) {
        f.x += (f.originX - f.x) * 0.06;
        f.y += (f.originY - f.y) * 0.06;
        f.rotation *= 0.94;
        f.tilt *= 0.95;
      }
      
      // Gold flows
      if (fragments.newSeams) {
        for (const seam of fragments.newSeams) {
          const seamStart = 0.15;
          const seamEnd = 0.85;
          if (progress > seamStart) {
            const seamProgress = (progress - seamStart) / (seamEnd - seamStart);
            seam.flowProgress = Math.min(1, seamProgress * 1.2);
            seam.progress = seam.flowProgress;
            
            // Spawn gold sparkles along flowing edge
            if (seam.flowProgress > 0 && seam.flowProgress < 1 && Math.random() < 0.35) {
              const t = seam.flowProgress;
              const x = seam.x1 + (seam.x2 - seam.x1) * t;
              const y = seam.y1 + (seam.y2 - seam.y1) * t;
              createGoldSparkle(x, y);
              // Sometimes spawn a second one nearby
              if (Math.random() < 0.3) {
                createGoldSparkle(x + (Math.random()-0.5)*15, y + (Math.random()-0.5)*15);
              }
            }
          }
        }
      }
    }
    
    function easeInOutQuart(t) {
      return t < 0.5 ? 8*t*t*t*t : 1 - Math.pow(-2*t + 2, 4) / 2;
    }
    
    // ========================================
    // RENDERING
    // ========================================
    
    function drawBowlBase(breathScale = 1) {
      ctx.save();
      
      const r = bowlRadius * breathScale;
      
      // Shadow
      const shadow = ctx.createRadialGradient(
        centerX + 5, centerY + 12, r * 0.85,
        centerX + 5, centerY + 12, r * 1.25
      );
      shadow.addColorStop(0, 'rgba(0,0,0,0.25)');
      shadow.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = shadow;
      ctx.beginPath();
      ctx.arc(centerX + 5, centerY + 12, r * 1.25, 0, Math.PI * 2);
      ctx.fill();
      
      // Main surface
      const mainGrad = ctx.createRadialGradient(
        centerX - r*0.35, centerY - r*0.35, 0,
        centerX + r*0.15, centerY + r*0.15, r * 1.1
      );
      mainGrad.addColorStop(0, COLORS.ceramicEdge);
      mainGrad.addColorStop(0.25, COLORS.ceramic);
      mainGrad.addColorStop(0.6, COLORS.ceramicMid);
      mainGrad.addColorStop(0.85, COLORS.ceramicShadow);
      mainGrad.addColorStop(1, COLORS.ceramicDark);
      
      ctx.fillStyle = mainGrad;
      ctx.beginPath();
      ctx.arc(centerX, centerY, r, 0, Math.PI * 2);
      ctx.fill();
      
      // Inner depth
      const innerGrad = ctx.createRadialGradient(
        centerX + r*0.08, centerY + r*0.08, 0,
        centerX, centerY, r * 0.55
      );
      innerGrad.addColorStop(0, 'rgba(0,0,0,0.07)');
      innerGrad.addColorStop(0.7, 'rgba(0,0,0,0.03)');
      innerGrad.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = innerGrad;
      ctx.beginPath();
      ctx.arc(centerX, centerY, r * 0.55, 0, Math.PI * 2);
      ctx.fill();
      
      // Rim highlight
      ctx.strokeStyle = 'rgba(255,255,255,0.18)';
      ctx.lineWidth = 2.5;
      ctx.beginPath();
      ctx.arc(centerX, centerY, r - 1.5, -Math.PI * 0.85, -Math.PI * 0.15);
      ctx.stroke();
      
      ctx.restore();
    }
    
    function drawFragment(f) {
      if (f.vertices.length < 3) return;
      
      ctx.save();
      ctx.translate(f.x, f.y);
      ctx.rotate(f.rotation);
      
      // 3D tilt effect via skew
      ctx.transform(1, f.tilt * 0.1, 0, 1, 0, 0);
      
      // Shadow under fragment
      ctx.fillStyle = 'rgba(0,0,0,0.15)';
      ctx.beginPath();
      ctx.moveTo(f.vertices[0].x + 4, f.vertices[0].y + 6);
      for (let i = 1; i < f.vertices.length; i++) {
        ctx.lineTo(f.vertices[i].x + 4, f.vertices[i].y + 6);
      }
      ctx.closePath();
      ctx.fill();
      
      // Fragment edge (thickness)
      ctx.fillStyle = COLORS.rawEdge;
      ctx.beginPath();
      ctx.moveTo(f.vertices[0].x, f.vertices[0].y);
      for (let i = 1; i < f.vertices.length; i++) {
        ctx.lineTo(f.vertices[i].x, f.vertices[i].y);
      }
      ctx.closePath();
      ctx.fill();
      
      // Main surface (slightly offset to show thickness)
      const offset = -2;
      const surfaceGrad = ctx.createRadialGradient(
        offset - 20, offset - 20, 0,
        offset, offset, bowlRadius * 0.5
      );
      surfaceGrad.addColorStop(0, COLORS.ceramic);
      surfaceGrad.addColorStop(1, COLORS.ceramicShadow);
      
      ctx.fillStyle = surfaceGrad;
      ctx.beginPath();
      ctx.moveTo(f.vertices[0].x + offset, f.vertices[0].y + offset);
      for (let i = 1; i < f.vertices.length; i++) {
        ctx.lineTo(f.vertices[i].x + offset, f.vertices[i].y + offset);
      }
      ctx.closePath();
      ctx.fill();
      
      // Edge highlight
      ctx.strokeStyle = 'rgba(255,255,255,0.2)';
      ctx.lineWidth = 1;
      ctx.stroke();
      
      ctx.restore();
    }
    
    function drawGoldSeams(seams, flowing = false) {
      if (!seams || seams.length === 0) return;
      
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      
      for (const seam of seams) {
        if (seam.progress <= 0) continue;
        
        const p = seam.flowProgress !== undefined ? seam.flowProgress : seam.progress;
        const x2 = seam.x1 + (seam.x2 - seam.x1) * p;
        const y2 = seam.y1 + (seam.y2 - seam.y1) * p;
        
        // Ambient glow (wider, softer)
        ctx.shadowColor = 'rgba(255, 190, 50, 0.6)';
        ctx.shadowBlur = flowing ? 25 : 15;
        
        // Outer glow layer
        ctx.strokeStyle = 'rgba(255, 200, 60, 0.2)';
        ctx.lineWidth = 14;
        ctx.beginPath();
        ctx.moveTo(seam.x1, seam.y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
        
        ctx.shadowBlur = 0;
        
        // Mid glow
        ctx.strokeStyle = 'rgba(255, 190, 50, 0.35)';
        ctx.lineWidth = 8;
        ctx.beginPath();
        ctx.moveTo(seam.x1, seam.y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
        
        // Main gold body
        ctx.strokeStyle = COLORS.gold;
        ctx.lineWidth = 4.5;
        ctx.beginPath();
        ctx.moveTo(seam.x1, seam.y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
        
        // Bright center highlight
        ctx.strokeStyle = COLORS.goldBright;
        ctx.lineWidth = 1.8;
        ctx.beginPath();
        ctx.moveTo(seam.x1, seam.y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
        
        // Flowing leading edge effect
        if (flowing && p > 0 && p < 1) {
          // Bright droplet at the leading edge
          ctx.fillStyle = COLORS.goldBright;
          ctx.shadowColor = 'rgba(255, 220, 100, 0.9)';
          ctx.shadowBlur = 12;
          ctx.beginPath();
          ctx.arc(x2, y2, 4, 0, Math.PI * 2);
          ctx.fill();
          ctx.shadowBlur = 0;
          
          // Liquid drip effect (slight bulge behind leading edge)
          const dripT = Math.max(0, p - 0.05);
          const dripX = seam.x1 + (seam.x2 - seam.x1) * dripT;
          const dripY = seam.y1 + (seam.y2 - seam.y1) * dripT;
          ctx.fillStyle = 'rgba(255, 210, 80, 0.5)';
          ctx.beginPath();
          ctx.arc(dripX, dripY, 3, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    }
    
    function drawTension(intensity) {
      ctx.save();
      
      // Radial cracks from break point
      const numCracks = Math.floor(4 + intensity * 12);
      ctx.strokeStyle = `rgba(80, 70, 60, ${intensity * 0.6})`;
      ctx.lineWidth = 0.8;
      
      for (let i = 0; i < numCracks; i++) {
        const baseAngle = (i / numCracks) * Math.PI * 2;
        const angle = baseAngle + Math.sin(Date.now() * 0.008 + i * 1.5) * 0.15 * intensity;
        const length = bowlRadius * (0.15 + intensity * 0.7);
        
        ctx.beginPath();
        
        let x = breakPoint.x;
        let y = breakPoint.y;
        ctx.moveTo(x, y);
        
        const steps = 6;
        for (let j = 1; j <= steps; j++) {
          const t = j / steps;
          const jitter = (Math.random() - 0.5) * 12 * intensity * t;
          x = breakPoint.x + Math.cos(angle) * length * t + jitter;
          y = breakPoint.y + Math.sin(angle) * length * t + jitter * 0.5;
          ctx.lineTo(x, y);
        }
        ctx.stroke();
      }
      
      ctx.restore();
      
      // Screen shake
      if (intensity > 0.3) {
        const shake = (intensity - 0.3) * 6;
        return { x: (Math.random()-0.5) * shake, y: (Math.random()-0.5) * shake };
      }
      return { x: 0, y: 0 };
    }
    
    // ========================================
    // MAIN LOOP
    // ========================================
    
    function update() {
      const now = Date.now();
      breathPhase += 0.02;
      
      updateParticles();
      
      switch (state) {
        case 'whole':
          break;
          
        case 'tension':
          holdTime = (now - holdStart) / 1000;
          if (!isHolding) {
            const intensity = Math.min(1, holdTime / 1.8);
            createFragments(0.6 + intensity * 0.4, breakPoint.x, breakPoint.y);
            state = 'shattered';
            stateTimer = now;
            breakCount++;
          }
          break;
          
        case 'shattered':
          if (updatePhysics() || now - stateTimer > 2800) {
            state = 'pause';
            stateTimer = now;
          }
          break;
          
        case 'pause':
          if (now - stateTimer > 2200) {
            state = 'mending';
            stateTimer = now;
          }
          break;
          
        case 'mending':
          const progress = Math.min(1, (now - stateTimer) / 14000);
          updateMending(progress);
          
          if (progress >= 1) {
            if (fragments.newSeams) {
              goldSeams.push(...fragments.newSeams.map(s => ({ ...s, progress: 1 })));
            }
            fragments = [];
            dustParticles = [];
            goldParticles = [];
            state = 'whole';
          }
          break;
      }
    }
    
    function draw() {
      ctx.fillStyle = COLORS.bg;
      ctx.fillRect(0, 0, size, size);
      
      ctx.save();
      
      if (state === 'whole') {
        // Subtle breathing
        const breath = 1 + Math.sin(breathPhase) * 0.003;
        drawBowlBase(breath);
        drawGoldSeams(goldSeams);
        
        // Hover glow
        if (isHovering) {
          const pulse = 0.4 + Math.sin(Date.now() * 0.005) * 0.3;
          ctx.strokeStyle = `rgba(212, 168, 71, ${pulse * 0.25})`;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(centerX, centerY, bowlRadius + 8, 0, Math.PI * 2);
          ctx.stroke();
        }
      }
      else if (state === 'tension') {
        const intensity = Math.min(1, holdTime / 1.8);
        const shake = drawTension(intensity);
        ctx.translate(shake.x, shake.y);
        drawBowlBase();
        drawGoldSeams(goldSeams);
      }
      else if (state === 'shattered' || state === 'pause') {
        for (const f of fragments) drawFragment(f);
        drawParticles();
      }
      else if (state === 'mending') {
        // Warmth bloom - subtle golden tint as healing progresses
        const mendProgress = Math.min(1, (Date.now() - stateTimer) / 14000);
        const warmth = Math.sin(mendProgress * Math.PI) * 0.08; // peaks at middle
        if (warmth > 0) {
          ctx.fillStyle = `rgba(255, 200, 100, ${warmth})`;
          ctx.fillRect(0, 0, size, size);
        }
        
        for (const f of fragments) drawFragment(f);
        drawGoldSeams(goldSeams);
        drawGoldSeams(fragments.newSeams, true);
        drawParticles();
      }
      
      ctx.restore();
    }
    
    function animate() {
      update();
      draw();
      requestAnimationFrame(animate);
    }
    
    // ========================================
    // INPUT
    // ========================================
    
    function getCanvasCoords(clientX, clientY) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: (clientX - rect.left) * (canvas.width / rect.width),
        y: (clientY - rect.top) * (canvas.height / rect.height)
      };
    }
    
    function isInsideBowl(clientX, clientY) {
      const { x, y } = getCanvasCoords(clientX, clientY);
      return Math.hypot(x - centerX, y - centerY) < bowlRadius;
    }
    
    function startHold(clientX, clientY) {
      if (state !== 'whole') return;
      
      const coords = getCanvasCoords(clientX, clientY);
      breakPoint = { x: coords.x, y: coords.y };
      
      isHolding = true;
      holdStart = Date.now();
      holdTime = 0;
      state = 'tension';
    }
    
    function endHold() {
      isHolding = false;
    }
    
    canvas.addEventListener('mousedown', e => {
      if (isInsideBowl(e.clientX, e.clientY)) startHold(e.clientX, e.clientY);
    });
    canvas.addEventListener('mouseup', endHold);
    canvas.addEventListener('mouseleave', endHold);
    canvas.addEventListener('mousemove', e => {
      const inside = isInsideBowl(e.clientX, e.clientY);
      isHovering = inside && state === 'whole';
      canvas.style.cursor = isHovering ? 'pointer' : 'default';
      
      if (state === 'tension' && isHolding) {
        const coords = getCanvasCoords(e.clientX, e.clientY);
        breakPoint = { x: coords.x, y: coords.y };
      }
    });
    
    canvas.addEventListener('touchstart', e => {
      e.preventDefault();
      const t = e.touches[0];
      if (isInsideBowl(t.clientX, t.clientY)) startHold(t.clientX, t.clientY);
    }, { passive: false });
    canvas.addEventListener('touchmove', e => {
      e.preventDefault();
      if (state === 'tension' && isHolding) {
        const t = e.touches[0];
        const coords = getCanvasCoords(t.clientX, t.clientY);
        breakPoint = { x: coords.x, y: coords.y };
      }
    }, { passive: false });
    canvas.addEventListener('touchend', e => { e.preventDefault(); endHold(); }, { passive: false });
    
    // ========================================
    // INIT
    // ========================================
    
    window.addEventListener('resize', resize);
    resize();
    animate();
  </script>
</body>
</html>
