<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Kintsugi</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #1a1918;
      touch-action: none;
    }
    canvas {
      display: block;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  
  <script>
    // ========================================
    // KINTSUGI - 金継ぎ
    // The Japanese art of golden repair
    // ========================================
    
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    // ========================================
    // AUDIO
    // ========================================
    
    let audioCtx = null;
    let audioEnabled = false;
    
    function initAudio() {
      if (audioCtx) return;
      try {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        audioEnabled = true;
      } catch (e) {
        audioEnabled = false;
      }
    }
    
    function playBreakSound(intensity) {
      if (!audioEnabled || !audioCtx) return;
      
      const duration = 0.15 + intensity * 0.15;
      const now = audioCtx.currentTime;
      
      const bufferSize = audioCtx.sampleRate * duration;
      const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) {
        const t = i / bufferSize;
        const envelope = Math.exp(-t * 12) * (1 - t);
        data[i] = (Math.random() * 2 - 1) * envelope;
      }
      
      const noise = audioCtx.createBufferSource();
      noise.buffer = buffer;
      
      const filter = audioCtx.createBiquadFilter();
      filter.type = 'bandpass';
      filter.frequency.value = 1800 + intensity * 2000;
      filter.Q.value = 1.2;
      
      const gain = audioCtx.createGain();
      gain.gain.value = 0.25 + intensity * 0.25;
      
      noise.connect(filter);
      filter.connect(gain);
      gain.connect(audioCtx.destination);
      
      noise.start(now);
      noise.stop(now + duration);
      
      const osc = audioCtx.createOscillator();
      osc.type = 'triangle';
      osc.frequency.value = 350 + intensity * 250;
      
      const oscGain = audioCtx.createGain();
      oscGain.gain.setValueAtTime(0.08, now);
      oscGain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
      
      osc.connect(oscGain);
      oscGain.connect(audioCtx.destination);
      osc.start(now);
      osc.stop(now + 0.12);
    }
    
    let goldDrone = null;
    let goldDroneGain = null;
    
    function startGoldSound() {
      if (!audioEnabled || !audioCtx) return;
      if (goldDrone) return;
      
      const now = audioCtx.currentTime;
      
      goldDrone = audioCtx.createOscillator();
      goldDrone.type = 'sine';
      goldDrone.frequency.value = 174;
      
      const harm2 = audioCtx.createOscillator();
      harm2.type = 'sine';
      harm2.frequency.value = 174 * 2;
      
      const harm3 = audioCtx.createOscillator();
      harm3.type = 'sine';
      harm3.frequency.value = 174 * 3;
      
      goldDroneGain = audioCtx.createGain();
      goldDroneGain.gain.setValueAtTime(0, now);
      goldDroneGain.gain.linearRampToValueAtTime(0.08, now + 2);
      
      const harm2Gain = audioCtx.createGain();
      harm2Gain.gain.value = 0.03;
      
      const harm3Gain = audioCtx.createGain();
      harm3Gain.gain.value = 0.015;
      
      goldDrone.connect(goldDroneGain);
      harm2.connect(harm2Gain);
      harm3.connect(harm3Gain);
      
      harm2Gain.connect(goldDroneGain);
      harm3Gain.connect(goldDroneGain);
      
      goldDroneGain.connect(audioCtx.destination);
      
      goldDrone.start(now);
      harm2.start(now);
      harm3.start(now);
      
      goldDrone._harmonics = [harm2, harm3];
    }
    
    function stopGoldSound() {
      if (!goldDrone || !audioCtx) return;
      
      const now = audioCtx.currentTime;
      goldDroneGain.gain.linearRampToValueAtTime(0, now + 1.5);
      
      setTimeout(() => {
        if (goldDrone) {
          goldDrone.stop();
          goldDrone._harmonics.forEach(h => h.stop());
          goldDrone = null;
          goldDroneGain = null;
        }
      }, 1600);
    }
    
    function playCompleteSound() {
      if (!audioEnabled || !audioCtx) return;
      
      const now = audioCtx.currentTime;
      const freqs = [261.63, 329.63, 392];
      
      freqs.forEach((freq, i) => {
        const osc = audioCtx.createOscillator();
        osc.type = 'sine';
        osc.frequency.value = freq;
        
        const gain = audioCtx.createGain();
        gain.gain.setValueAtTime(0, now + i * 0.1);
        gain.gain.linearRampToValueAtTime(0.06, now + i * 0.1 + 0.3);
        gain.gain.linearRampToValueAtTime(0, now + i * 0.1 + 2);
        
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        
        osc.start(now + i * 0.1);
        osc.stop(now + i * 0.1 + 2.1);
      });
    }
    
    let size, centerX, centerY, bowlRadius;
    
    function resize() {
      const minDim = Math.min(window.innerWidth, window.innerHeight);
      size = Math.min(minDim * 0.95, 650);
      canvas.width = size;
      canvas.height = size;
      centerX = size / 2;
      centerY = size / 2;
      bowlRadius = size * 0.36;
      generateLacquerPattern();
    }
    
    // ========================================
    // COLORS
    // ========================================
    
    const COLORS = {
      bg: '#1a1918',
      ceramic: '#ebe7e2',
      ceramicMid: '#d8d4ce',
      ceramicShadow: '#c4bfb8',
      ceramicDark: '#a8a39c',
      ceramicEdge: '#f5f2ef',
      rawEdge: '#d0ccc6',
      gold: '#d4a847',
      goldBright: '#ffe566',
      goldMid: '#c9973d',
      goldDark: '#8b6914',
      goldGlow: 'rgba(255, 210, 80, 0.5)',
      // Lacquer colors
      lacquerRed: '#8b2323',
      lacquerBlack: '#1a1a1a',
      lacquerGold: '#c9973d',
      lacquerCream: '#f5f0e8',
    };
    
    // ========================================
    // LACQUER PATTERN GENERATION
    // ========================================
    
    let lacquerElements = [];
    
    function generateLacquerPattern() {
      lacquerElements = [];
      const seed = Math.random() * 10000;
      
      // Seeded random for consistent patterns
      const seededRandom = (offset = 0) => {
        const x = Math.sin(seed + offset) * 10000;
        return x - Math.floor(x);
      };
      
      // Layer 1: Geometric foundation - subtle circles and arcs
      const numCircles = 8 + Math.floor(seededRandom(0) * 6);
      for (let i = 0; i < numCircles; i++) {
        const angle = seededRandom(i * 10) * Math.PI * 2;
        const dist = seededRandom(i * 10 + 1) * bowlRadius * 0.7;
        const r = 8 + seededRandom(i * 10 + 2) * 35;
        lacquerElements.push({
          type: 'circle',
          x: Math.cos(angle) * dist,
          y: Math.sin(angle) * dist,
          r: r,
          filled: seededRandom(i * 10 + 3) > 0.6,
          color: seededRandom(i * 10 + 4) > 0.7 ? COLORS.lacquerGold : 
                 seededRandom(i * 10 + 4) > 0.3 ? COLORS.lacquerRed : COLORS.lacquerBlack,
          alpha: 0.15 + seededRandom(i * 10 + 5) * 0.25
        });
      }
      
      // Layer 2: Flowing lines - like brushstrokes or branches
      const numCurves = 5 + Math.floor(seededRandom(100) * 4);
      for (let i = 0; i < numCurves; i++) {
        const startAngle = seededRandom(i * 20 + 100) * Math.PI * 2;
        const startDist = seededRandom(i * 20 + 101) * bowlRadius * 0.5;
        const points = [];
        let x = Math.cos(startAngle) * startDist;
        let y = Math.sin(startAngle) * startDist;
        let angle = seededRandom(i * 20 + 102) * Math.PI * 2;
        
        const numPoints = 4 + Math.floor(seededRandom(i * 20 + 103) * 5);
        for (let j = 0; j < numPoints; j++) {
          points.push({ x, y });
          const step = 15 + seededRandom(i * 20 + j * 3 + 104) * 30;
          angle += (seededRandom(i * 20 + j * 3 + 105) - 0.5) * 1.2;
          x += Math.cos(angle) * step;
          y += Math.sin(angle) * step;
        }
        
        lacquerElements.push({
          type: 'curve',
          points: points,
          width: 1 + seededRandom(i * 20 + 106) * 3,
          color: seededRandom(i * 20 + 107) > 0.6 ? COLORS.lacquerGold : COLORS.lacquerRed,
          alpha: 0.2 + seededRandom(i * 20 + 108) * 0.3
        });
      }
      
      // Layer 3: Petals and leaves - nature motifs
      const numMotifs = 3 + Math.floor(seededRandom(200) * 3);
      for (let i = 0; i < numMotifs; i++) {
        const angle = seededRandom(i * 30 + 200) * Math.PI * 2;
        const dist = bowlRadius * (0.2 + seededRandom(i * 30 + 201) * 0.5);
        const x = Math.cos(angle) * dist;
        const y = Math.sin(angle) * dist;
        const petalCount = 4 + Math.floor(seededRandom(i * 30 + 202) * 4);
        const petalSize = 12 + seededRandom(i * 30 + 203) * 20;
        
        lacquerElements.push({
          type: 'flower',
          x: x,
          y: y,
          petalCount: petalCount,
          petalSize: petalSize,
          rotation: seededRandom(i * 30 + 204) * Math.PI * 2,
          color: seededRandom(i * 30 + 205) > 0.5 ? COLORS.lacquerGold : COLORS.lacquerCream,
          alpha: 0.15 + seededRandom(i * 30 + 206) * 0.2
        });
      }
      
      // Layer 4: Wave patterns (seigaiha-inspired)
      const numWaves = 2 + Math.floor(seededRandom(300) * 2);
      for (let i = 0; i < numWaves; i++) {
        const startY = (seededRandom(i * 40 + 300) - 0.5) * bowlRadius * 1.2;
        lacquerElements.push({
          type: 'wave',
          y: startY,
          amplitude: 8 + seededRandom(i * 40 + 301) * 12,
          frequency: 3 + seededRandom(i * 40 + 302) * 4,
          color: COLORS.lacquerGold,
          alpha: 0.12 + seededRandom(i * 40 + 303) * 0.15
        });
      }
      
      // Layer 5: Scattered dots - like gold dust (nashiji)
      const numDots = 30 + Math.floor(seededRandom(400) * 40);
      for (let i = 0; i < numDots; i++) {
        const angle = seededRandom(i * 5 + 400) * Math.PI * 2;
        const dist = seededRandom(i * 5 + 401) * bowlRadius * 0.85;
        lacquerElements.push({
          type: 'dot',
          x: Math.cos(angle) * dist,
          y: Math.sin(angle) * dist,
          r: 0.8 + seededRandom(i * 5 + 402) * 2,
          color: COLORS.lacquerGold,
          alpha: 0.2 + seededRandom(i * 5 + 403) * 0.4
        });
      }
    }
    
    function drawLacquerPattern() {
      ctx.save();
      ctx.translate(centerX, centerY);
      
      // Clip to bowl shape
      ctx.beginPath();
      ctx.arc(0, 0, bowlRadius - 3, 0, Math.PI * 2);
      ctx.clip();
      
      for (const el of lacquerElements) {
        ctx.globalAlpha = el.alpha;
        
        switch (el.type) {
          case 'circle':
            ctx.beginPath();
            ctx.arc(el.x, el.y, el.r, 0, Math.PI * 2);
            if (el.filled) {
              ctx.fillStyle = el.color;
              ctx.fill();
            } else {
              ctx.strokeStyle = el.color;
              ctx.lineWidth = 1.5;
              ctx.stroke();
            }
            break;
            
          case 'curve':
            if (el.points.length < 2) break;
            ctx.beginPath();
            ctx.moveTo(el.points[0].x, el.points[0].y);
            for (let i = 1; i < el.points.length; i++) {
              const prev = el.points[i - 1];
              const curr = el.points[i];
              const cpx = (prev.x + curr.x) / 2;
              const cpy = (prev.y + curr.y) / 2;
              ctx.quadraticCurveTo(prev.x, prev.y, cpx, cpy);
            }
            ctx.strokeStyle = el.color;
            ctx.lineWidth = el.width;
            ctx.lineCap = 'round';
            ctx.stroke();
            break;
            
          case 'flower':
            ctx.save();
            ctx.translate(el.x, el.y);
            ctx.rotate(el.rotation);
            ctx.fillStyle = el.color;
            for (let p = 0; p < el.petalCount; p++) {
              const pAngle = (p / el.petalCount) * Math.PI * 2;
              ctx.save();
              ctx.rotate(pAngle);
              ctx.beginPath();
              ctx.ellipse(el.petalSize * 0.5, 0, el.petalSize * 0.5, el.petalSize * 0.25, 0, 0, Math.PI * 2);
              ctx.fill();
              ctx.restore();
            }
            // Center
            ctx.beginPath();
            ctx.arc(0, 0, el.petalSize * 0.15, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
            break;
            
          case 'wave':
            ctx.beginPath();
            ctx.strokeStyle = el.color;
            ctx.lineWidth = 1.2;
            for (let x = -bowlRadius; x <= bowlRadius; x += 2) {
              const y = el.y + Math.sin(x / bowlRadius * Math.PI * el.frequency) * el.amplitude;
              if (x === -bowlRadius) ctx.moveTo(x, y);
              else ctx.lineTo(x, y);
            }
            ctx.stroke();
            break;
            
          case 'dot':
            ctx.beginPath();
            ctx.arc(el.x, el.y, el.r, 0, Math.PI * 2);
            ctx.fillStyle = el.color;
            ctx.fill();
            break;
        }
      }
      
      ctx.restore();
    }
    
    // ========================================
    // STATE
    // ========================================
    
    let state = 'whole';
    let holdTime = 0;
    let holdStart = 0;
    let isHolding = false;
    let stateTimer = 0;
    let breakPoint = { x: centerX, y: centerY };
    
    let fragments = [];
    let goldSeams = [];
    let dustParticles = [];
    let goldParticles = [];
    let breakCount = 0;
    let isHovering = false;
    let breathPhase = 0;
    
    // ========================================
    // ORGANIC FRAGMENTATION
    // ========================================
    
    function createOrganicCrack(startX, startY, angle, length, depth, cracks) {
      if (depth > 4 || length < 8) return;
      
      const points = [{ x: startX, y: startY }];
      let x = startX;
      let y = startY;
      let currentAngle = angle;
      let traveled = 0;
      
      // Organic step-by-step crack propagation
      while (traveled < length) {
        // Natural variation in direction
        currentAngle += (Math.random() - 0.5) * 0.6;
        
        // Step size varies - ceramic fractures are irregular
        const stepSize = 8 + Math.random() * 15;
        x += Math.cos(currentAngle) * stepSize;
        y += Math.sin(currentAngle) * stepSize;
        traveled += stepSize;
        
        // Check if still in bowl
        const distFromCenter = Math.hypot(x - centerX, y - centerY);
        if (distFromCenter > bowlRadius * 0.95) break;
        
        points.push({ x, y });
        
        // Random branching - more likely early, at junctions
        if (Math.random() < 0.25 * (1 - traveled / length) && depth < 3) {
          const branchAngle = currentAngle + (Math.random() > 0.5 ? 1 : -1) * (0.4 + Math.random() * 0.8);
          const branchLength = length * (0.3 + Math.random() * 0.4);
          createOrganicCrack(x, y, branchAngle, branchLength, depth + 1, cracks);
        }
      }
      
      if (points.length > 1) {
        cracks.push(points);
      }
    }
    
    function createFragments(intensity, impactX, impactY) {
      fragments = [];
      const cracks = [];
      
      // Number of main cracks scales with intensity
      const numMainCracks = Math.floor(4 + intensity * 8);
      
      // Generate organic cracks radiating from impact point
      for (let i = 0; i < numMainCracks; i++) {
        // Distribute angles with some randomness
        const baseAngle = (i / numMainCracks) * Math.PI * 2;
        const angle = baseAngle + (Math.random() - 0.5) * (Math.PI / numMainCracks);
        
        // Length based on intensity and some randomness
        const maxLength = bowlRadius * (0.5 + intensity * 0.5);
        const length = maxLength * (0.6 + Math.random() * 0.4);
        
        createOrganicCrack(impactX, impactY, angle, length, 0, cracks);
      }
      
      // Add concentric ring cracks for high intensity
      if (intensity > 0.5) {
        const numRings = Math.floor(1 + intensity * 2);
        for (let ring = 0; ring < numRings; ring++) {
          const radius = bowlRadius * (0.25 + ring * 0.25) * (0.8 + Math.random() * 0.4);
          const arcStart = Math.random() * Math.PI * 2;
          const arcLength = Math.PI * (0.3 + Math.random() * 0.5);
          
          const points = [];
          const steps = 12;
          for (let s = 0; s <= steps; s++) {
            const a = arcStart + (s / steps) * arcLength;
            const r = radius + (Math.random() - 0.5) * 10;
            points.push({
              x: centerX + Math.cos(a) * r,
              y: centerY + Math.sin(a) * r
            });
          }
          if (points.length > 1) cracks.push(points);
        }
      }
      
      // Convert cracks to seams for gold repair
      const newSeams = [];
      for (const crack of cracks) {
        for (let i = 0; i < crack.length - 1; i++) {
          newSeams.push({
            x1: crack[i].x,
            y1: crack[i].y,
            x2: crack[i + 1].x,
            y2: crack[i + 1].y,
            progress: 0,
            flowProgress: 0,
            // Vary thickness naturally
            thickness: 2.5 + Math.random() * 3,
            // Mark intersections for pooling
            isJunction: i === 0 || i === crack.length - 2
          });
        }
      }
      
      // Find intersection points for gold pooling
      const pools = [];
      for (let i = 0; i < newSeams.length; i++) {
        for (let j = i + 1; j < newSeams.length; j++) {
          const intersection = lineIntersection(newSeams[i], newSeams[j]);
          if (intersection) {
            pools.push({
              x: intersection.x,
              y: intersection.y,
              size: 4 + Math.random() * 4,
              progress: 0
            });
          }
        }
      }
      
      // Create fragment shapes from crack network using flood fill approach
      createFragmentsFromCracks(cracks, impactX, impactY, intensity);
      
      fragments.newSeams = newSeams;
      fragments.pools = pools;
      
      createDustBurst(impactX, impactY, intensity);
    }
    
    function lineIntersection(s1, s2) {
      const x1 = s1.x1, y1 = s1.y1, x2 = s1.x2, y2 = s1.y2;
      const x3 = s2.x1, y3 = s2.y1, x4 = s2.x2, y4 = s2.y2;
      
      const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
      if (Math.abs(denom) < 0.001) return null;
      
      const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
      const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;
      
      if (t > 0.1 && t < 0.9 && u > 0.1 && u < 0.9) {
        return {
          x: x1 + t * (x2 - x1),
          y: y1 + t * (y2 - y1)
        };
      }
      return null;
    }
    
    function createFragmentsFromCracks(cracks, impactX, impactY, intensity) {
      // Simplified: create radial pie-slice fragments that follow crack lines
      const numSlices = Math.max(6, cracks.length);
      
      // Collect all crack endpoints as potential fragment boundaries
      const angles = [];
      for (const crack of cracks) {
        if (crack.length > 1) {
          const lastPt = crack[crack.length - 1];
          const angle = Math.atan2(lastPt.y - centerY, lastPt.x - centerX);
          angles.push(angle);
        }
      }
      
      // Sort angles and fill gaps
      angles.sort((a, b) => a - b);
      
      // Ensure we have enough angles
      while (angles.length < numSlices) {
        // Find largest gap and insert midpoint
        let maxGap = 0;
        let maxIdx = 0;
        for (let i = 0; i < angles.length; i++) {
          const next = (i + 1) % angles.length;
          let gap = angles[next] - angles[i];
          if (next === 0) gap += Math.PI * 2;
          if (gap > maxGap) {
            maxGap = gap;
            maxIdx = i;
          }
        }
        const newAngle = angles[maxIdx] + maxGap / 2;
        angles.splice(maxIdx + 1, 0, newAngle > Math.PI ? newAngle - Math.PI * 2 : newAngle);
      }
      
      // Create fragment for each angular slice
      for (let i = 0; i < angles.length; i++) {
        const a1 = angles[i];
        const a2 = angles[(i + 1) % angles.length];
        
        // Create irregular fragment shape
        const verts = [];
        verts.push({ x: centerX, y: centerY });
        
        // Outer edge with irregularity
        const steps = 4;
        let a = a1;
        const aDiff = ((a2 - a1 + Math.PI * 3) % (Math.PI * 2)) - Math.PI;
        const aStep = aDiff / steps;
        
        for (let s = 0; s <= steps; s++) {
          const r = bowlRadius * (0.95 + (Math.random() - 0.5) * 0.08);
          verts.push({
            x: centerX + Math.cos(a) * r,
            y: centerY + Math.sin(a) * r
          });
          a += aStep;
        }
        
        // Calculate centroid
        let cx = 0, cy = 0;
        for (const v of verts) { cx += v.x; cy += v.y; }
        cx /= verts.length;
        cy /= verts.length;
        
        // Velocity based on distance from impact
        const impactDist = Math.hypot(cx - impactX, cy - impactY);
        const impactInfluence = Math.max(0.3, 1 - impactDist / (bowlRadius * 1.2));
        
        const outwardAngle = Math.atan2(cy - centerY, cx - centerX);
        const speed = (2 + Math.random() * 3) * intensity * impactInfluence;
        
        fragments.push({
          vertices: verts.map(v => ({ x: v.x - cx, y: v.y - cy })),
          x: cx,
          y: cy,
          originX: cx,
          originY: cy,
          vx: Math.cos(outwardAngle) * speed * 0.8 + (Math.random() - 0.5) * 1.5,
          vy: Math.sin(outwardAngle) * speed * 0.8 + (Math.random() - 0.5) * 1.5,
          rotation: 0,
          rotationVel: (Math.random() - 0.5) * 0.15 * intensity,
          thickness: 6 + Math.random() * 4
        });
      }
    }
    
    // ========================================
    // PARTICLES
    // ========================================
    
    function createDustBurst(x, y, intensity) {
      const count = Math.floor(20 + intensity * 35);
      
      for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = (0.5 + Math.random() * 2.5) * intensity;
        const size = 0.8 + Math.random() * 2.5;
        
        dustParticles.push({
          x, y,
          vx: Math.cos(angle) * speed + (Math.random() - 0.5) * 2,
          vy: Math.sin(angle) * speed - Math.random() * 3,
          size,
          life: 1,
          decay: 0.012 + Math.random() * 0.018,
          gravity: 0.04 + Math.random() * 0.04
        });
      }
    }
    
    function createGoldSparkle(x, y, large = false) {
      goldParticles.push({
        x: x + (Math.random() - 0.5) * 12,
        y: y + (Math.random() - 0.5) * 12,
        vx: (Math.random() - 0.5) * 0.6,
        vy: (Math.random() - 0.5) * 0.6 - 0.4,
        size: large ? 2 + Math.random() * 3 : 1 + Math.random() * 2,
        life: 1,
        decay: 0.015 + Math.random() * 0.02,
        shimmer: Math.random() * Math.PI * 2
      });
    }
    
    function updateParticles() {
      for (let i = dustParticles.length - 1; i >= 0; i--) {
        const p = dustParticles[i];
        p.vy += p.gravity;
        p.x += p.vx;
        p.y += p.vy;
        p.vx *= 0.98;
        p.vy *= 0.98;
        p.life -= p.decay;
        if (p.life <= 0) dustParticles.splice(i, 1);
      }
      
      for (let i = goldParticles.length - 1; i >= 0; i--) {
        const p = goldParticles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.shimmer += 0.3;
        p.life -= p.decay;
        if (p.life <= 0) goldParticles.splice(i, 1);
      }
    }
    
    function drawParticles() {
      for (const p of dustParticles) {
        ctx.globalAlpha = p.life * 0.6;
        ctx.fillStyle = COLORS.rawEdge;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
      }
      
      for (const p of goldParticles) {
        const alpha = p.life * p.life;
        const shimmerBrightness = 0.7 + Math.sin(p.shimmer) * 0.3;
        ctx.globalAlpha = alpha * shimmerBrightness;
        
        ctx.fillStyle = 'rgba(255, 200, 80, 0.4)';
        ctx.shadowColor = 'rgba(255, 200, 100, 0.8)';
        ctx.shadowBlur = 15;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size * 2.5, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.shadowBlur = 8;
        ctx.fillStyle = COLORS.goldBright;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.shadowBlur = 0;
        ctx.fillStyle = `rgba(255, 255, 240, ${0.9 * shimmerBrightness})`;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size * 0.4, 0, Math.PI * 2);
        ctx.fill();
      }
      
      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;
    }
    
    // ========================================
    // PHYSICS
    // ========================================
    
    function updatePhysics() {
      const gravity = 0.025;
      const friction = 0.96;
      const bounce = 0.4;
      const boundary = bowlRadius * 1.3;
      
      let settled = true;
      
      for (const f of fragments) {
        f.vy += gravity;
        f.x += f.vx;
        f.y += f.vy;
        f.vx *= friction;
        f.vy *= friction;
        f.rotation += f.rotationVel;
        f.rotationVel *= 0.97;
        
        const distFromCenter = Math.hypot(f.x - centerX, f.y - centerY);
        if (distFromCenter > boundary) {
          const angle = Math.atan2(f.y - centerY, f.x - centerX);
          f.x = centerX + Math.cos(angle) * boundary;
          f.y = centerY + Math.sin(angle) * boundary;
          f.vx *= -bounce;
          f.vy *= -bounce;
        }
        
        if (Math.abs(f.vx) > 0.15 || Math.abs(f.vy) > 0.15) settled = false;
      }
      
      return settled;
    }
    
    function updateMending(progress) {
      const eased = easeInOutQuart(progress);
      
      for (const f of fragments) {
        f.x += (f.originX - f.x) * 0.06;
        f.y += (f.originY - f.y) * 0.06;
        f.rotation *= 0.94;
      }
      
      if (fragments.newSeams) {
        for (const seam of fragments.newSeams) {
          const seamStart = 0.15;
          const seamEnd = 0.85;
          if (progress > seamStart) {
            const seamProgress = (progress - seamStart) / (seamEnd - seamStart);
            seam.flowProgress = Math.min(1, seamProgress * 1.2);
            seam.progress = seam.flowProgress;
            
            if (seam.flowProgress > 0 && seam.flowProgress < 1 && Math.random() < 0.4) {
              const t = seam.flowProgress;
              const x = seam.x1 + (seam.x2 - seam.x1) * t;
              const y = seam.y1 + (seam.y2 - seam.y1) * t;
              createGoldSparkle(x, y);
              if (Math.random() < 0.25) {
                createGoldSparkle(x, y, true);
              }
            }
          }
        }
      }
      
      // Update pool progress
      if (fragments.pools) {
        for (const pool of fragments.pools) {
          if (progress > 0.3) {
            pool.progress = Math.min(1, (progress - 0.3) / 0.5);
          }
        }
      }
    }
    
    function easeInOutQuart(t) {
      return t < 0.5 ? 8 * t * t * t * t : 1 - Math.pow(-2 * t + 2, 4) / 2;
    }
    
    // ========================================
    // RENDERING
    // ========================================
    
    function drawBowlBase(breathScale = 1) {
      ctx.save();
      
      const r = bowlRadius * breathScale;
      
      // Shadow
      const shadow = ctx.createRadialGradient(
        centerX + 5, centerY + 12, r * 0.85,
        centerX + 5, centerY + 12, r * 1.25
      );
      shadow.addColorStop(0, 'rgba(0,0,0,0.25)');
      shadow.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = shadow;
      ctx.beginPath();
      ctx.arc(centerX + 5, centerY + 12, r * 1.25, 0, Math.PI * 2);
      ctx.fill();
      
      // Main surface
      const mainGrad = ctx.createRadialGradient(
        centerX - r * 0.35, centerY - r * 0.35, 0,
        centerX + r * 0.15, centerY + r * 0.15, r * 1.1
      );
      mainGrad.addColorStop(0, COLORS.ceramicEdge);
      mainGrad.addColorStop(0.25, COLORS.ceramic);
      mainGrad.addColorStop(0.6, COLORS.ceramicMid);
      mainGrad.addColorStop(0.85, COLORS.ceramicShadow);
      mainGrad.addColorStop(1, COLORS.ceramicDark);
      
      ctx.fillStyle = mainGrad;
      ctx.beginPath();
      ctx.arc(centerX, centerY, r, 0, Math.PI * 2);
      ctx.fill();
      
      // Draw lacquer pattern
      drawLacquerPattern();
      
      // Inner depth
      const innerGrad = ctx.createRadialGradient(
        centerX + r * 0.08, centerY + r * 0.08, 0,
        centerX, centerY, r * 0.55
      );
      innerGrad.addColorStop(0, 'rgba(0,0,0,0.07)');
      innerGrad.addColorStop(0.7, 'rgba(0,0,0,0.03)');
      innerGrad.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = innerGrad;
      ctx.beginPath();
      ctx.arc(centerX, centerY, r * 0.55, 0, Math.PI * 2);
      ctx.fill();
      
      // Rim highlight
      ctx.strokeStyle = 'rgba(255,255,255,0.18)';
      ctx.lineWidth = 2.5;
      ctx.beginPath();
      ctx.arc(centerX, centerY, r - 1.5, -Math.PI * 0.85, -Math.PI * 0.15);
      ctx.stroke();
      
      ctx.restore();
    }
    
    function drawFragment(f) {
      if (f.vertices.length < 3) return;
      
      ctx.save();
      ctx.translate(f.x, f.y);
      ctx.rotate(f.rotation);
      
      // Shadow under fragment
      ctx.fillStyle = 'rgba(0,0,0,0.3)';
      ctx.beginPath();
      ctx.moveTo(f.vertices[0].x + 3, f.vertices[0].y + 5);
      for (let i = 1; i < f.vertices.length; i++) {
        ctx.lineTo(f.vertices[i].x + 3, f.vertices[i].y + 5);
      }
      ctx.closePath();
      ctx.fill();
      
      // Raw edge
      ctx.fillStyle = COLORS.ceramicShadow;
      ctx.strokeStyle = COLORS.ceramicDark;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(f.vertices[0].x, f.vertices[0].y);
      for (let i = 1; i < f.vertices.length; i++) {
        ctx.lineTo(f.vertices[i].x, f.vertices[i].y);
      }
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      
      // Main ceramic surface
      const offset = -3;
      
      // Clip to fragment shape for lacquer
      ctx.save();
      ctx.beginPath();
      ctx.moveTo(f.vertices[0].x + offset, f.vertices[0].y + offset);
      for (let i = 1; i < f.vertices.length; i++) {
        ctx.lineTo(f.vertices[i].x + offset, f.vertices[i].y + offset);
      }
      ctx.closePath();
      ctx.clip();
      
      // Base ceramic color
      ctx.fillStyle = COLORS.ceramic;
      ctx.fillRect(-bowlRadius, -bowlRadius, bowlRadius * 2, bowlRadius * 2);
      
      // Draw lacquer elements that fall within this fragment
      // Transform to world coords for pattern
      const worldX = f.originX;
      const worldY = f.originY;
      
      ctx.translate(-worldX + centerX, -worldY + centerY);
      for (const el of lacquerElements) {
        ctx.globalAlpha = el.alpha;
        
        switch (el.type) {
          case 'circle':
            ctx.beginPath();
            ctx.arc(el.x, el.y, el.r, 0, Math.PI * 2);
            if (el.filled) {
              ctx.fillStyle = el.color;
              ctx.fill();
            } else {
              ctx.strokeStyle = el.color;
              ctx.lineWidth = 1.5;
              ctx.stroke();
            }
            break;
            
          case 'dot':
            ctx.beginPath();
            ctx.arc(el.x, el.y, el.r, 0, Math.PI * 2);
            ctx.fillStyle = el.color;
            ctx.fill();
            break;
            
          case 'flower':
            ctx.save();
            ctx.translate(el.x, el.y);
            ctx.rotate(el.rotation);
            ctx.fillStyle = el.color;
            for (let p = 0; p < el.petalCount; p++) {
              const pAngle = (p / el.petalCount) * Math.PI * 2;
              ctx.save();
              ctx.rotate(pAngle);
              ctx.beginPath();
              ctx.ellipse(el.petalSize * 0.5, 0, el.petalSize * 0.5, el.petalSize * 0.25, 0, 0, Math.PI * 2);
              ctx.fill();
              ctx.restore();
            }
            ctx.beginPath();
            ctx.arc(0, 0, el.petalSize * 0.15, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
            break;
        }
      }
      ctx.globalAlpha = 1;
      
      ctx.restore();
      
      // Light edge on ceramic surface
      ctx.strokeStyle = COLORS.ceramicEdge;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(f.vertices[0].x + offset, f.vertices[0].y + offset);
      for (let i = 1; i < f.vertices.length; i++) {
        ctx.lineTo(f.vertices[i].x + offset, f.vertices[i].y + offset);
      }
      ctx.closePath();
      ctx.stroke();
      
      ctx.restore();
    }
    
    function drawFluidGoldSeam(seam, flowing = false, time = 0) {
      if (seam.progress <= 0) return;
      
      const p = seam.flowProgress !== undefined ? seam.flowProgress : seam.progress;
      const x1 = seam.x1, y1 = seam.y1;
      const x2 = seam.x1 + (seam.x2 - seam.x1) * p;
      const y2 = seam.y1 + (seam.y2 - seam.y1) * p;
      
      const length = Math.hypot(x2 - x1, y2 - y1);
      if (length < 2) return;
      
      const baseThickness = seam.thickness || 3.5;
      const shimmer = 0.85 + Math.sin(time * 0.003 + seam.x1 * 0.1) * 0.15;
      
      // Draw gold as a fluid ribbon with varying thickness
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      
      // Ambient glow - wider, softer
      ctx.shadowColor = `rgba(255, 190, 50, ${0.5 * shimmer})`;
      ctx.shadowBlur = flowing ? 28 : 18;
      
      // Outer glow layer
      ctx.strokeStyle = `rgba(255, 200, 60, ${0.15 * shimmer})`;
      ctx.lineWidth = baseThickness * 4;
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
      
      // Build fluid path with thickness variation
      const angle = Math.atan2(y2 - y1, x2 - x1);
      const perpAngle = angle + Math.PI / 2;
      const steps = Math.max(4, Math.floor(length / 8));
      
      // Create organic thickness variation along the seam
      const thicknessPoints = [];
      for (let i = 0; i <= steps; i++) {
        const t = i / steps;
        const tx = x1 + (x2 - x1) * t;
        const ty = y1 + (y2 - y1) * t;
        
        // Organic thickness variation - thicker in middle, varies with noise
        const midFactor = 1 - Math.abs(t - 0.5) * 0.6;
        const noise = Math.sin(t * 12 + seam.x1) * 0.3 + Math.sin(t * 7 + seam.y1) * 0.2;
        const thickness = baseThickness * (0.7 + midFactor * 0.5 + noise * 0.3);
        
        thicknessPoints.push({ x: tx, y: ty, thickness });
      }
      
      ctx.shadowBlur = 0;
      
      // Draw fluid gold body with smooth edges
      ctx.beginPath();
      // Top edge
      ctx.moveTo(
        thicknessPoints[0].x + Math.cos(perpAngle) * thicknessPoints[0].thickness,
        thicknessPoints[0].y + Math.sin(perpAngle) * thicknessPoints[0].thickness
      );
      for (let i = 1; i < thicknessPoints.length; i++) {
        const pt = thicknessPoints[i];
        ctx.lineTo(
          pt.x + Math.cos(perpAngle) * pt.thickness,
          pt.y + Math.sin(perpAngle) * pt.thickness
        );
      }
      // Bottom edge (reverse)
      for (let i = thicknessPoints.length - 1; i >= 0; i--) {
        const pt = thicknessPoints[i];
        ctx.lineTo(
          pt.x - Math.cos(perpAngle) * pt.thickness,
          pt.y - Math.sin(perpAngle) * pt.thickness
        );
      }
      ctx.closePath();
      
      // Gold gradient fill
      const goldGrad = ctx.createLinearGradient(x1, y1, x2, y2);
      goldGrad.addColorStop(0, COLORS.goldDark);
      goldGrad.addColorStop(0.3, COLORS.gold);
      goldGrad.addColorStop(0.5, COLORS.goldBright);
      goldGrad.addColorStop(0.7, COLORS.gold);
      goldGrad.addColorStop(1, COLORS.goldMid);
      
      ctx.fillStyle = goldGrad;
      ctx.fill();
      
      // Bright highlight line down the center
      ctx.strokeStyle = `rgba(255, 240, 180, ${0.6 * shimmer})`;
      ctx.lineWidth = baseThickness * 0.4;
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
      
      // Specular highlight spots
      const numHighlights = Math.floor(length / 25);
      for (let i = 0; i < numHighlights; i++) {
        const ht = (i + 0.5) / (numHighlights + 1);
        const hx = x1 + (x2 - x1) * ht + (Math.sin(time * 0.002 + i) * 2);
        const hy = y1 + (y2 - y1) * ht + (Math.cos(time * 0.002 + i) * 2);
        const hs = baseThickness * (0.3 + shimmer * 0.3);
        
        ctx.fillStyle = `rgba(255, 255, 240, ${0.5 * shimmer})`;
        ctx.beginPath();
        ctx.arc(hx, hy, hs, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Flowing leading edge effect
      if (flowing && p > 0 && p < 1) {
        // Molten gold droplet at leading edge
        const dropSize = baseThickness * 1.8;
        
        ctx.shadowColor = 'rgba(255, 220, 100, 0.9)';
        ctx.shadowBlur = 15;
        
        // Outer glow
        ctx.fillStyle = 'rgba(255, 200, 80, 0.5)';
        ctx.beginPath();
        ctx.arc(x2, y2, dropSize * 1.5, 0, Math.PI * 2);
        ctx.fill();
        
        // Main droplet
        ctx.fillStyle = COLORS.goldBright;
        ctx.beginPath();
        ctx.arc(x2, y2, dropSize, 0, Math.PI * 2);
        ctx.fill();
        
        // Hot white center
        ctx.fillStyle = 'rgba(255, 255, 250, 0.9)';
        ctx.beginPath();
        ctx.arc(x2, y2, dropSize * 0.4, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.shadowBlur = 0;
        
        // Trailing drips behind leading edge
        for (let d = 1; d <= 3; d++) {
          const dripT = Math.max(0, p - d * 0.06);
          if (dripT > 0) {
            const dripX = seam.x1 + (seam.x2 - seam.x1) * dripT;
            const dripY = seam.y1 + (seam.y2 - seam.y1) * dripT;
            const dripSize = baseThickness * (0.8 - d * 0.15);
            
            ctx.fillStyle = `rgba(255, 210, 80, ${0.6 - d * 0.15})`;
            ctx.beginPath();
            ctx.arc(dripX, dripY, dripSize, 0, Math.PI * 2);
            ctx.fill();
          }
        }
      }
    }
    
    function drawGoldPool(pool, time) {
      if (pool.progress <= 0) return;
      
      const shimmer = 0.85 + Math.sin(time * 0.003 + pool.x * 0.05 + pool.y * 0.05) * 0.15;
      const size = pool.size * pool.progress;
      
      // Outer glow
      ctx.shadowColor = `rgba(255, 190, 50, ${0.6 * shimmer})`;
      ctx.shadowBlur = 20;
      
      ctx.fillStyle = `rgba(255, 200, 60, ${0.3 * shimmer})`;
      ctx.beginPath();
      ctx.arc(pool.x, pool.y, size * 2, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.shadowBlur = 0;
      
      // Main pool - slightly irregular
      ctx.beginPath();
      for (let a = 0; a < Math.PI * 2; a += 0.2) {
        const r = size * (0.9 + Math.sin(a * 3 + pool.x) * 0.15);
        const px = pool.x + Math.cos(a) * r;
        const py = pool.y + Math.sin(a) * r;
        if (a === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.closePath();
      
      const poolGrad = ctx.createRadialGradient(
        pool.x - size * 0.3, pool.y - size * 0.3, 0,
        pool.x, pool.y, size
      );
      poolGrad.addColorStop(0, COLORS.goldBright);
      poolGrad.addColorStop(0.4, COLORS.gold);
      poolGrad.addColorStop(1, COLORS.goldMid);
      
      ctx.fillStyle = poolGrad;
      ctx.fill();
      
      // Bright highlight
      ctx.fillStyle = `rgba(255, 255, 240, ${0.6 * shimmer})`;
      ctx.beginPath();
      ctx.arc(pool.x - size * 0.25, pool.y - size * 0.25, size * 0.35, 0, Math.PI * 2);
      ctx.fill();
    }
    
    function drawGoldSeams(seams, flowing = false) {
      if (!seams || seams.length === 0) return;
      
      const time = Date.now();
      
      for (const seam of seams) {
        drawFluidGoldSeam(seam, flowing, time);
      }
    }
    
    function drawGoldPools(pools) {
      if (!pools || pools.length === 0) return;
      
      const time = Date.now();
      
      for (const pool of pools) {
        drawGoldPool(pool, time);
      }
    }
    
    function drawTension(intensity) {
      ctx.save();
      
      const numCracks = Math.floor(5 + intensity * 15);
      ctx.strokeStyle = `rgba(80, 70, 60, ${intensity * 0.7})`;
      ctx.lineWidth = 0.8 + intensity * 0.4;
      
      for (let i = 0; i < numCracks; i++) {
        const baseAngle = (i / numCracks) * Math.PI * 2;
        const angle = baseAngle + Math.sin(Date.now() * 0.01 + i * 1.5) * 0.2 * intensity;
        const length = bowlRadius * (0.1 + intensity * 0.8);
        
        ctx.beginPath();
        
        let x = breakPoint.x;
        let y = breakPoint.y;
        ctx.moveTo(x, y);
        
        // More organic crack propagation
        const steps = 8;
        let currentAngle = angle;
        for (let j = 1; j <= steps; j++) {
          const t = j / steps;
          currentAngle += (Math.random() - 0.5) * 0.5 * intensity;
          const jitter = (Math.random() - 0.5) * 15 * intensity * t;
          const stepLen = (length / steps) * (0.8 + Math.random() * 0.4);
          x += Math.cos(currentAngle) * stepLen;
          y += Math.sin(currentAngle) * stepLen + jitter * 0.3;
          ctx.lineTo(x, y);
          
          // Branch occasionally
          if (intensity > 0.4 && Math.random() < 0.15 * intensity) {
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(x, y);
            const branchAngle = currentAngle + (Math.random() > 0.5 ? 1 : -1) * (0.3 + Math.random() * 0.5);
            const bx = x + Math.cos(branchAngle) * 15 * intensity;
            const by = y + Math.sin(branchAngle) * 15 * intensity;
            ctx.lineTo(bx, by);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(x, y);
          }
        }
        ctx.stroke();
      }
      
      ctx.restore();
      
      if (intensity > 0.3) {
        const shake = (intensity - 0.3) * 8;
        return { x: (Math.random() - 0.5) * shake, y: (Math.random() - 0.5) * shake };
      }
      return { x: 0, y: 0 };
    }
    
    // ========================================
    // MAIN LOOP
    // ========================================
    
    function update() {
      const now = Date.now();
      breathPhase += 0.02;
      
      updateParticles();
      
      switch (state) {
        case 'whole':
          break;
          
        case 'tension':
          holdTime = (now - holdStart) / 1000;
          if (!isHolding) {
            // Intensity based on hold duration - longer hold = more dramatic shatter
            const intensity = Math.min(1, 0.4 + holdTime / 2.5 * 0.6);
            createFragments(intensity, breakPoint.x, breakPoint.y);
            state = 'shattered';
            stateTimer = now;
            breakCount++;
            playBreakSound(intensity);
          }
          break;
          
        case 'shattered':
          if (updatePhysics() || now - stateTimer > 2500) {
            state = 'pause';
            stateTimer = now;
          }
          break;
          
        case 'pause':
          if (now - stateTimer > 2800) {
            state = 'mending';
            stateTimer = now;
            startGoldSound();
          }
          break;
          
        case 'mending':
          const progress = Math.min(1, (now - stateTimer) / 16000);
          updateMending(progress);
          
          if (progress >= 1) {
            if (fragments.newSeams) {
              goldSeams.push(...fragments.newSeams.map(s => ({ ...s, progress: 1, flowProgress: 1 })));
            }
            if (fragments.pools) {
              if (!goldSeams.pools) goldSeams.pools = [];
              goldSeams.pools.push(...fragments.pools.map(p => ({ ...p, progress: 1 })));
            }
            fragments = [];
            dustParticles = [];
            goldParticles = [];
            state = 'whole';
            stopGoldSound();
            playCompleteSound();
          }
          break;
      }
    }
    
    function draw() {
      ctx.fillStyle = COLORS.bg;
      ctx.fillRect(0, 0, size, size);
      
      ctx.save();
      
      if (state === 'whole') {
        const breath = 1 + Math.sin(breathPhase) * 0.003;
        drawBowlBase(breath);
        drawGoldSeams(goldSeams);
        if (goldSeams.pools) drawGoldPools(goldSeams.pools);
        
        if (isHovering) {
          const pulse = 0.4 + Math.sin(Date.now() * 0.005) * 0.3;
          ctx.strokeStyle = `rgba(212, 168, 71, ${pulse * 0.25})`;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(centerX, centerY, bowlRadius + 8, 0, Math.PI * 2);
          ctx.stroke();
        }
      }
      else if (state === 'tension') {
        const intensity = Math.min(1, holdTime / 2.5);
        const shake = drawTension(intensity);
        ctx.translate(shake.x, shake.y);
        drawBowlBase();
        drawGoldSeams(goldSeams);
        if (goldSeams.pools) drawGoldPools(goldSeams.pools);
      }
      else if (state === 'shattered' || state === 'pause') {
        for (const f of fragments) drawFragment(f);
        drawParticles();
      }
      else if (state === 'mending') {
        const mendProgress = Math.min(1, (Date.now() - stateTimer) / 16000);
        const warmth = Math.sin(mendProgress * Math.PI) * 0.06;
        if (warmth > 0) {
          ctx.fillStyle = `rgba(255, 200, 100, ${warmth})`;
          ctx.fillRect(0, 0, size, size);
        }
        
        for (const f of fragments) drawFragment(f);
        drawGoldSeams(goldSeams);
        if (goldSeams.pools) drawGoldPools(goldSeams.pools);
        drawGoldSeams(fragments.newSeams, true);
        if (fragments.pools) drawGoldPools(fragments.pools);
        drawParticles();
        
        if (mendProgress > 0.9) {
          const pulse = (mendProgress - 0.9) / 0.1;
          const pulseAlpha = Math.sin(pulse * Math.PI) * 0.1;
          ctx.fillStyle = `rgba(255, 220, 150, ${pulseAlpha})`;
          ctx.beginPath();
          ctx.arc(centerX, centerY, bowlRadius * 1.2, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      
      ctx.restore();
    }
    
    function animate() {
      update();
      draw();
      requestAnimationFrame(animate);
    }
    
    // ========================================
    // INPUT
    // ========================================
    
    function getCanvasCoords(clientX, clientY) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: (clientX - rect.left) * (canvas.width / rect.width),
        y: (clientY - rect.top) * (canvas.height / rect.height)
      };
    }
    
    function isInsideBowl(clientX, clientY) {
      const { x, y } = getCanvasCoords(clientX, clientY);
      return Math.hypot(x - centerX, y - centerY) < bowlRadius;
    }
    
    function startHold(clientX, clientY) {
      if (state !== 'whole') return;
      
      initAudio();
      
      const coords = getCanvasCoords(clientX, clientY);
      breakPoint = { x: coords.x, y: coords.y };
      
      isHolding = true;
      holdStart = Date.now();
      holdTime = 0;
      state = 'tension';
    }
    
    function endHold() {
      isHolding = false;
    }
    
    canvas.addEventListener('mousedown', e => {
      if (isInsideBowl(e.clientX, e.clientY)) startHold(e.clientX, e.clientY);
    });
    canvas.addEventListener('mouseup', endHold);
    canvas.addEventListener('mouseleave', endHold);
    canvas.addEventListener('mousemove', e => {
      const inside = isInsideBowl(e.clientX, e.clientY);
      isHovering = inside && state === 'whole';
      canvas.style.cursor = isHovering ? 'pointer' : 'default';
      
      if (state === 'tension' && isHolding) {
        const coords = getCanvasCoords(e.clientX, e.clientY);
        breakPoint = { x: coords.x, y: coords.y };
      }
    });
    
    canvas.addEventListener('touchstart', e => {
      e.preventDefault();
      const t = e.touches[0];
      if (isInsideBowl(t.clientX, t.clientY)) startHold(t.clientX, t.clientY);
    }, { passive: false });
    canvas.addEventListener('touchmove', e => {
      e.preventDefault();
      if (state === 'tension' && isHolding) {
        const t = e.touches[0];
        const coords = getCanvasCoords(t.clientX, t.clientY);
        breakPoint = { x: coords.x, y: coords.y };
      }
    }, { passive: false });
    canvas.addEventListener('touchend', e => { e.preventDefault(); endHold(); }, { passive: false });
    
    // ========================================
    // INIT
    // ========================================
    
    window.addEventListener('resize', resize);
    resize();
    animate();
  </script>
</body>
</html>
