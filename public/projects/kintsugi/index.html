<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Kintsugi</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #1a1918;
      touch-action: none;
    }
    canvas {
      display: block;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  
  <script>
    // ========================================
    // KINTSUGI - 金継ぎ
    // ========================================
    
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    // Sizing
    let size, centerX, centerY, bowlRadius;
    
    function resize() {
      const minDim = Math.min(window.innerWidth, window.innerHeight);
      size = Math.min(minDim * 0.9, 600);
      canvas.width = size;
      canvas.height = size;
      centerX = size / 2;
      centerY = size / 2;
      bowlRadius = size * 0.38;
    }
    
    // Colors
    const COLORS = {
      bg: '#1a1918',
      ceramic: '#e8e4df',
      ceramicMid: '#d5d0c9',
      ceramicShadow: '#c9c4bc',
      ceramicDark: '#b8b3ab',
      ceramicEdge: '#f0ece7',
      gold: '#d4a847',
      goldBright: '#ffe066',
      goldDark: '#a67c00',
    };
    
    // State
    let state = 'whole';
    let holdTime = 0;
    let holdStart = 0;
    let isHolding = false;
    let stateTimer = 0;
    
    let fragments = [];
    let goldSeams = [];
    let breakCount = 0;
    let isHovering = false;
    
    // ========================================
    // IMPROVED VORONOI
    // ========================================
    
    function generateSeedPoints(count, cx, cy, radius) {
      const points = [{ x: cx, y: cy, id: 0 }];
      
      // Use Poisson-like distribution for better spacing
      for (let i = 1; i < count; i++) {
        let bestDist = 0;
        let bestPoint = null;
        
        // Try several candidates, pick the one furthest from existing points
        for (let attempt = 0; attempt < 20; attempt++) {
          const angle = Math.random() * Math.PI * 2;
          const r = Math.sqrt(Math.random()) * radius * 0.85;
          const candidate = {
            x: cx + Math.cos(angle) * r,
            y: cy + Math.sin(angle) * r
          };
          
          let minDist = Infinity;
          for (const p of points) {
            const d = Math.hypot(candidate.x - p.x, candidate.y - p.y);
            minDist = Math.min(minDist, d);
          }
          
          if (minDist > bestDist) {
            bestDist = minDist;
            bestPoint = candidate;
          }
        }
        
        if (bestPoint) {
          points.push({ ...bestPoint, id: i });
        }
      }
      
      return points;
    }
    
    function getVoronoiCell(point, allPoints, cx, cy, radius) {
      // Build cell by finding perpendicular bisector intersections
      const vertices = [];
      const angles = [];
      
      // Start with a circle, then clip by each bisector
      const resolution = 72;
      let cellPoints = [];
      
      for (let i = 0; i < resolution; i++) {
        const angle = (i / resolution) * Math.PI * 2;
        cellPoints.push({
          x: point.x + Math.cos(angle) * radius * 2,
          y: point.y + Math.sin(angle) * radius * 2
        });
      }
      
      // Clip by bowl boundary
      cellPoints = clipPolygonToCircle(cellPoints, cx, cy, radius);
      
      // Clip by each bisector
      for (const other of allPoints) {
        if (other.id === point.id) continue;
        
        const midX = (point.x + other.x) / 2;
        const midY = (point.y + other.y) / 2;
        const dx = other.x - point.x;
        const dy = other.y - point.y;
        
        // Normal to the line between points
        const nx = -dy;
        const ny = dx;
        
        // Keep points on our side of the bisector
        cellPoints = clipPolygonByLine(cellPoints, midX, midY, nx, ny);
        
        if (cellPoints.length < 3) break;
      }
      
      return cellPoints;
    }
    
    function clipPolygonToCircle(poly, cx, cy, r) {
      if (poly.length < 3) return poly;
      
      const result = [];
      
      for (let i = 0; i < poly.length; i++) {
        const current = poly[i];
        const next = poly[(i + 1) % poly.length];
        
        const currentInside = Math.hypot(current.x - cx, current.y - cy) <= r;
        const nextInside = Math.hypot(next.x - cx, next.y - cy) <= r;
        
        if (currentInside) {
          result.push(current);
        }
        
        if (currentInside !== nextInside) {
          // Find intersection with circle
          const intersection = lineCircleIntersection(current, next, cx, cy, r);
          if (intersection) result.push(intersection);
        }
      }
      
      return result;
    }
    
    function lineCircleIntersection(p1, p2, cx, cy, r) {
      const dx = p2.x - p1.x;
      const dy = p2.y - p1.y;
      const fx = p1.x - cx;
      const fy = p1.y - cy;
      
      const a = dx * dx + dy * dy;
      const b = 2 * (fx * dx + fy * dy);
      const c = fx * fx + fy * fy - r * r;
      
      const discriminant = b * b - 4 * a * c;
      if (discriminant < 0) return null;
      
      const sqrtDisc = Math.sqrt(discriminant);
      let t = (-b - sqrtDisc) / (2 * a);
      
      if (t < 0 || t > 1) {
        t = (-b + sqrtDisc) / (2 * a);
      }
      
      if (t < 0 || t > 1) return null;
      
      return {
        x: p1.x + t * dx,
        y: p1.y + t * dy
      };
    }
    
    function clipPolygonByLine(poly, px, py, nx, ny) {
      if (poly.length < 3) return poly;
      
      const result = [];
      
      for (let i = 0; i < poly.length; i++) {
        const current = poly[i];
        const next = poly[(i + 1) % poly.length];
        
        const currentSide = (current.x - px) * nx + (current.y - py) * ny;
        const nextSide = (next.x - px) * nx + (next.y - py) * ny;
        
        if (currentSide >= 0) {
          result.push(current);
        }
        
        if ((currentSide >= 0) !== (nextSide >= 0)) {
          // Find intersection
          const t = currentSide / (currentSide - nextSide);
          result.push({
            x: current.x + t * (next.x - current.x),
            y: current.y + t * (next.y - current.y)
          });
        }
      }
      
      return result;
    }
    
    function createFragments(intensity) {
      const numPoints = Math.floor(6 + intensity * 12);
      const seedPoints = generateSeedPoints(numPoints, centerX, centerY, bowlRadius);
      
      fragments = [];
      const newSeams = [];
      
      for (const seed of seedPoints) {
        const cellVertices = getVoronoiCell(seed, seedPoints, centerX, centerY, bowlRadius);
        
        if (cellVertices.length < 3) continue;
        
        // Calculate centroid
        let cx = 0, cy = 0;
        for (const v of cellVertices) {
          cx += v.x;
          cy += v.y;
        }
        cx /= cellVertices.length;
        cy /= cellVertices.length;
        
        // Physics
        const angle = Math.atan2(cy - centerY, cx - centerX);
        const dist = Math.hypot(cx - centerX, cy - centerY);
        const speed = (3 + Math.random() * 4) * intensity;
        const scatter = (0.3 + dist / bowlRadius * 0.7);
        
        fragments.push({
          vertices: cellVertices.map(v => ({ x: v.x - cx, y: v.y - cy })),
          x: cx,
          y: cy,
          originX: cx,
          originY: cy,
          vx: Math.cos(angle + (Math.random() - 0.5) * 0.8) * speed * scatter,
          vy: Math.sin(angle + (Math.random() - 0.5) * 0.8) * speed * scatter - 2,
          rotation: 0,
          rotationVel: (Math.random() - 0.5) * 0.15 * intensity,
          scale: 1
        });
        
        // Create seams along internal edges
        for (let i = 0; i < cellVertices.length; i++) {
          const v1 = cellVertices[i];
          const v2 = cellVertices[(i + 1) % cellVertices.length];
          
          // Check if this edge is on the bowl boundary
          const mid = { x: (v1.x + v2.x) / 2, y: (v1.y + v2.y) / 2 };
          const distFromCenter = Math.hypot(mid.x - centerX, mid.y - centerY);
          
          if (distFromCenter < bowlRadius - 5) {
            // Internal edge - will become gold seam
            newSeams.push({
              x1: v1.x,
              y1: v1.y,
              x2: v2.x,
              y2: v2.y,
              progress: 0,
              glowPhase: Math.random() * Math.PI * 2
            });
          }
        }
      }
      
      // Store new seams for animation
      fragments.newSeams = newSeams;
    }
    
    // ========================================
    // PHYSICS & ANIMATION
    // ========================================
    
    function updatePhysics() {
      const gravity = 0.15;
      const friction = 0.985;
      const bounce = 0.3;
      const boundary = bowlRadius * 2;
      
      let allStopped = true;
      
      for (const f of fragments) {
        f.vy += gravity;
        f.x += f.vx;
        f.y += f.vy;
        f.vx *= friction;
        f.vy *= friction;
        f.rotation += f.rotationVel;
        f.rotationVel *= 0.98;
        
        // Ground collision (bottom of canvas area)
        if (f.y > centerY + boundary) {
          f.y = centerY + boundary;
          f.vy *= -bounce;
          f.rotationVel *= 0.5;
        }
        
        // Side boundaries
        if (f.x < centerX - boundary) {
          f.x = centerX - boundary;
          f.vx *= -bounce;
        }
        if (f.x > centerX + boundary) {
          f.x = centerX + boundary;
          f.vx *= -bounce;
        }
        
        if (Math.abs(f.vx) > 0.1 || Math.abs(f.vy) > 0.1) {
          allStopped = false;
        }
      }
      
      return allStopped;
    }
    
    function updateMending(progress) {
      const eased = easeInOutQuart(progress);
      
      for (const f of fragments) {
        f.x += (f.originX - f.x) * 0.08;
        f.y += (f.originY - f.y) * 0.08;
        f.rotation *= 0.92;
      }
      
      // Animate gold seams
      if (fragments.newSeams) {
        const seamProgress = Math.max(0, (progress - 0.2) / 0.6);
        for (const seam of fragments.newSeams) {
          seam.progress = Math.min(1, seamProgress * 1.5);
        }
      }
    }
    
    function easeInOutQuart(t) {
      return t < 0.5 ? 8 * t * t * t * t : 1 - Math.pow(-2 * t + 2, 4) / 2;
    }
    
    // ========================================
    // RENDERING
    // ========================================
    
    function drawBowlBase() {
      // Outer glow/shadow
      const outerGlow = ctx.createRadialGradient(
        centerX, centerY + 10, bowlRadius * 0.9,
        centerX, centerY + 10, bowlRadius * 1.2
      );
      outerGlow.addColorStop(0, 'rgba(0,0,0,0.2)');
      outerGlow.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = outerGlow;
      ctx.beginPath();
      ctx.arc(centerX, centerY + 10, bowlRadius * 1.2, 0, Math.PI * 2);
      ctx.fill();
      
      // Main bowl surface
      const bowlGrad = ctx.createRadialGradient(
        centerX - bowlRadius * 0.3, centerY - bowlRadius * 0.3, 0,
        centerX + bowlRadius * 0.2, centerY + bowlRadius * 0.2, bowlRadius * 1.2
      );
      bowlGrad.addColorStop(0, COLORS.ceramicEdge);
      bowlGrad.addColorStop(0.3, COLORS.ceramic);
      bowlGrad.addColorStop(0.7, COLORS.ceramicMid);
      bowlGrad.addColorStop(1, COLORS.ceramicDark);
      
      ctx.fillStyle = bowlGrad;
      ctx.beginPath();
      ctx.arc(centerX, centerY, bowlRadius, 0, Math.PI * 2);
      ctx.fill();
      
      // Inner depth
      const innerDepth = ctx.createRadialGradient(
        centerX + bowlRadius * 0.1, centerY + bowlRadius * 0.1, 0,
        centerX, centerY, bowlRadius * 0.5
      );
      innerDepth.addColorStop(0, 'rgba(0,0,0,0.06)');
      innerDepth.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = innerDepth;
      ctx.beginPath();
      ctx.arc(centerX, centerY, bowlRadius * 0.5, 0, Math.PI * 2);
      ctx.fill();
      
      // Rim highlight
      ctx.strokeStyle = 'rgba(255,255,255,0.15)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(centerX, centerY, bowlRadius - 1, -Math.PI * 0.8, -Math.PI * 0.2);
      ctx.stroke();
    }
    
    function drawGoldSeams(seams) {
      if (!seams || seams.length === 0) return;
      
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      
      // Glow layer
      ctx.shadowColor = 'rgba(255, 200, 50, 0.6)';
      ctx.shadowBlur = 12;
      
      for (const seam of seams) {
        if (seam.progress <= 0) continue;
        
        const x2 = seam.x1 + (seam.x2 - seam.x1) * seam.progress;
        const y2 = seam.y1 + (seam.y2 - seam.y1) * seam.progress;
        
        // Outer glow
        ctx.strokeStyle = 'rgba(255, 200, 50, 0.3)';
        ctx.lineWidth = 8;
        ctx.beginPath();
        ctx.moveTo(seam.x1, seam.y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
      }
      
      ctx.shadowBlur = 0;
      
      for (const seam of seams) {
        if (seam.progress <= 0) continue;
        
        const x2 = seam.x1 + (seam.x2 - seam.x1) * seam.progress;
        const y2 = seam.y1 + (seam.y2 - seam.y1) * seam.progress;
        
        // Main gold line
        ctx.strokeStyle = COLORS.gold;
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(seam.x1, seam.y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
        
        // Bright center
        ctx.strokeStyle = COLORS.goldBright;
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(seam.x1, seam.y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
      }
    }
    
    function drawFragment(f, alpha = 1) {
      if (f.vertices.length < 3) return;
      
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.translate(f.x, f.y);
      ctx.rotate(f.rotation);
      
      // Fragment fill with gradient
      const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, bowlRadius * 0.4);
      grad.addColorStop(0, COLORS.ceramic);
      grad.addColorStop(1, COLORS.ceramicShadow);
      
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.moveTo(f.vertices[0].x, f.vertices[0].y);
      for (let i = 1; i < f.vertices.length; i++) {
        ctx.lineTo(f.vertices[i].x, f.vertices[i].y);
      }
      ctx.closePath();
      ctx.fill();
      
      // Light edge
      ctx.strokeStyle = 'rgba(255,255,255,0.3)';
      ctx.lineWidth = 1;
      ctx.stroke();
      
      ctx.restore();
    }
    
    function drawTension(intensity) {
      // Hairline cracks appearing
      ctx.save();
      
      const numCracks = Math.floor(3 + intensity * 10);
      ctx.strokeStyle = `rgba(100, 90, 80, ${intensity * 0.5})`;
      ctx.lineWidth = 0.5;
      
      for (let i = 0; i < numCracks; i++) {
        const baseAngle = (i / numCracks) * Math.PI * 2;
        const angle = baseAngle + Math.sin(Date.now() * 0.005 + i * 2) * 0.2;
        const length = bowlRadius * (0.2 + intensity * 0.6) * (0.5 + Math.random() * 0.5);
        
        ctx.beginPath();
        ctx.moveTo(
          centerX + Math.cos(angle) * 10,
          centerY + Math.sin(angle) * 10
        );
        
        // Jagged crack
        let x = centerX + Math.cos(angle) * 10;
        let y = centerY + Math.sin(angle) * 10;
        const steps = 5;
        for (let j = 0; j < steps; j++) {
          const t = (j + 1) / steps;
          const jitter = (Math.random() - 0.5) * 10 * intensity;
          x = centerX + Math.cos(angle + jitter * 0.01) * (10 + length * t);
          y = centerY + Math.sin(angle + jitter * 0.01) * (10 + length * t);
          ctx.lineTo(x + jitter, y + jitter);
        }
        ctx.stroke();
      }
      
      ctx.restore();
      
      // Tremble
      if (intensity > 0.4) {
        const shake = (intensity - 0.4) * 5;
        return {
          x: (Math.random() - 0.5) * shake,
          y: (Math.random() - 0.5) * shake
        };
      }
      return { x: 0, y: 0 };
    }
    
    // ========================================
    // MAIN LOOP
    // ========================================
    
    function update() {
      const now = Date.now();
      
      switch (state) {
        case 'whole':
          break;
          
        case 'tension':
          holdTime = (now - holdStart) / 1000;
          if (!isHolding) {
            const intensity = Math.min(1, holdTime / 2);
            createFragments(0.5 + intensity * 0.5);
            state = 'shattered';
            stateTimer = now;
            breakCount++;
          }
          break;
          
        case 'shattered':
          const settled = updatePhysics();
          if (settled || now - stateTimer > 2500) {
            state = 'pause';
            stateTimer = now;
          }
          break;
          
        case 'pause':
          if (now - stateTimer > 2000) {
            state = 'mending';
            stateTimer = now;
          }
          break;
          
        case 'mending':
          const progress = Math.min(1, (now - stateTimer) / 12000);
          updateMending(progress);
          
          if (progress >= 1) {
            // Commit gold seams
            if (fragments.newSeams) {
              goldSeams.push(...fragments.newSeams.map(s => ({ ...s, progress: 1 })));
            }
            fragments = [];
            state = 'whole';
          }
          break;
      }
    }
    
    function draw() {
      ctx.fillStyle = COLORS.bg;
      ctx.fillRect(0, 0, size, size);
      
      ctx.save();
      
      let shake = { x: 0, y: 0 };
      
      if (state === 'whole') {
        drawBowlBase();
        drawGoldSeams(goldSeams);
        
        // Hover hint
        if (isHovering) {
          const pulse = 0.5 + Math.sin(Date.now() * 0.004) * 0.5;
          ctx.strokeStyle = `rgba(212, 168, 71, ${pulse * 0.2})`;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(centerX, centerY, bowlRadius + 5, 0, Math.PI * 2);
          ctx.stroke();
        }
      }
      else if (state === 'tension') {
        const intensity = Math.min(1, holdTime / 2);
        shake = drawTension(intensity);
        ctx.translate(shake.x, shake.y);
        drawBowlBase();
        drawGoldSeams(goldSeams);
      }
      else if (state === 'shattered' || state === 'pause') {
        for (const f of fragments) {
          drawFragment(f);
        }
      }
      else if (state === 'mending') {
        for (const f of fragments) {
          drawFragment(f);
        }
        drawGoldSeams(goldSeams);
        drawGoldSeams(fragments.newSeams);
      }
      
      ctx.restore();
    }
    
    function animate() {
      update();
      draw();
      requestAnimationFrame(animate);
    }
    
    // ========================================
    // INPUT
    // ========================================
    
    function isInsideBowl(clientX, clientY) {
      const rect = canvas.getBoundingClientRect();
      const x = (clientX - rect.left) * (canvas.width / rect.width);
      const y = (clientY - rect.top) * (canvas.height / rect.height);
      return Math.hypot(x - centerX, y - centerY) < bowlRadius;
    }
    
    function startHold() {
      if (state !== 'whole') return;
      isHolding = true;
      holdStart = Date.now();
      holdTime = 0;
      state = 'tension';
    }
    
    function endHold() {
      isHolding = false;
    }
    
    canvas.addEventListener('mousedown', e => {
      if (isInsideBowl(e.clientX, e.clientY)) startHold();
    });
    canvas.addEventListener('mouseup', endHold);
    canvas.addEventListener('mouseleave', endHold);
    canvas.addEventListener('mousemove', e => {
      isHovering = isInsideBowl(e.clientX, e.clientY) && state === 'whole';
      canvas.style.cursor = isHovering ? 'pointer' : 'default';
    });
    
    canvas.addEventListener('touchstart', e => {
      e.preventDefault();
      if (isInsideBowl(e.touches[0].clientX, e.touches[0].clientY)) startHold();
    }, { passive: false });
    canvas.addEventListener('touchend', e => {
      e.preventDefault();
      endHold();
    }, { passive: false });
    
    // ========================================
    // INIT
    // ========================================
    
    window.addEventListener('resize', resize);
    resize();
    animate();
  </script>
</body>
</html>
