<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>decay — memory</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; height: 100%; overflow: hidden; background: #0a0a0a; }
    canvas { display: block; }
  
    /* Navigation */
    .sf-nav { position: fixed; top: 20px; left: 20px; z-index: 1000; display: flex; gap: 12px; }
    .sf-nav a, .sf-nav button { 
      background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.1);
      color: rgba(255,255,255,0.4); text-decoration: none; font-size: 18px; 
      width: 36px; height: 36px; border-radius: 50%; display: flex; 
      align-items: center; justify-content: center; cursor: pointer;
      transition: all 0.3s; font-family: system-ui, sans-serif;
    }
    .sf-nav a:hover, .sf-nav button:hover { 
      background: rgba(0,0,0,0.5); color: rgba(255,255,255,0.8);
      border-color: rgba(255,255,255,0.3);
    }
    /* Modal */
    .sf-modal { 
      position: fixed; inset: 0; background: rgba(0,0,0,0.9); z-index: 2000;
      display: none; align-items: center; justify-content: center; padding: 20px;
    }
    .sf-modal.open { display: flex; }
    .sf-modal-content {
      background: #111; border: 1px solid #333; border-radius: 12px;
      max-width: 500px; width: 100%; max-height: 80vh; overflow-y: auto;
      padding: 30px; color: #ddd; font-family: system-ui, sans-serif;
    }
    .sf-modal h2 { margin: 0 0 20px; font-weight: 400; font-size: 24px; color: #fff; }
    .sf-modal h3 { margin: 20px 0 8px; font-weight: 500; font-size: 12px; 
      text-transform: uppercase; letter-spacing: 1px; color: #888; }
    .sf-modal p { margin: 0; line-height: 1.6; font-size: 15px; color: #aaa; }
    .sf-modal-close { 
      position: absolute; top: 20px; right: 20px; background: none; border: none;
      color: #666; font-size: 24px; cursor: pointer; padding: 10px;
    }
    .sf-modal-close:hover { color: #fff; }

  </style>
</head>
<body>

  <!-- Navigation -->
  <nav class="sf-nav">
    <a href="/" title="Back to gallery">←</a>
    <button onclick="document.getElementById('sf-modal').classList.add('open')" title="About this piece">?</button>
  </nav>
  
  <!-- Info Modal -->
  <div id="sf-modal" class="sf-modal" onclick="if(event.target===this)this.classList.remove('open')">
    <button class="sf-modal-close" onclick="document.getElementById('sf-modal').classList.remove('open')">×</button>
    <div class="sf-modal-content">
      <h2>Decay: Memory</h2>
      <h3>Concept</h3>
      <p>Words that fade as you read them. The act of observation degrades what it touches — like memories that blur each time we recall them.</p>
      <h3>Interaction</h3>
      <p>Move your cursor over text to accelerate its decay. The words corrupt and fade. Tap to spawn new memories.</p>
    </div>
  </div>

<canvas id="canvas"></canvas>
  
  <script type="module">
    import { createInteraction } from '../../lib/starfish-interact.js';
    
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const input = createInteraction(canvas);
    
    let width, height;
    
    function resize() {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
    }
    resize();
    window.addEventListener('resize', resize);
    
    // Fragments of memory
    const phrases = [
      "the way light fell through the window",
      "I can almost remember",
      "your voice saying something important",
      "the color of that room",
      "we were laughing about",
      "it felt like summer",
      "the smell of rain on concrete",
      "I think you said",
      "that song was playing",
      "before everything changed",
      "the exact words escape me",
      "it was Tuesday or maybe",
      "I keep trying to hold onto",
      "faces blur at the edges",
      "was it you or someone else",
      "the feeling remains but",
      "details slip like water",
      "I remember remembering",
    ];
    
    let memories = [];
    
    class Memory {
      constructor(text, x, y) {
        this.text = text;
        this.chars = text.split('').map((char, i) => ({
          char,
          x: x + i * 14,
          y: y,
          opacity: 1,
          decay: 0,
          offsetX: 0,
          offsetY: 0,
          intact: true
        }));
        this.baseX = x;
        this.baseY = y;
      }
      
      update(cursorX, cursorY) {
        let allGone = true;
        
        this.chars.forEach((c, i) => {
          if (!c.intact) return;
          
          // Distance from cursor
          const dx = cursorX - c.x;
          const dy = cursorY - c.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          // Observation causes decay
          if (dist < 80) {
            const intensity = 1 - dist / 80;
            c.decay += intensity * 0.02;
            
            // Characters drift
            c.offsetX += (Math.random() - 0.5) * intensity * 0.5;
            c.offsetY += (Math.random() - 0.5) * intensity * 0.3;
          }
          
          // Natural slow decay
          c.decay += 0.0005;
          
          // Opacity follows decay
          c.opacity = Math.max(0, 1 - c.decay);
          
          // Character corruption
          if (c.decay > 0.5 && Math.random() < 0.01) {
            c.char = String.fromCharCode(c.char.charCodeAt(0) + Math.floor(Math.random() * 5) - 2);
          }
          
          // Character death
          if (c.decay > 1) {
            c.intact = false;
          } else {
            allGone = false;
          }
        });
        
        return !allGone;
      }
      
      draw(ctx) {
        ctx.font = '16px Georgia, serif';
        
        this.chars.forEach(c => {
          if (!c.intact) return;
          
          // Color shifts as it decays
          const hue = 40 - c.decay * 40;
          const sat = 10 + c.decay * 20;
          const light = 70 - c.decay * 30;
          
          ctx.fillStyle = `hsla(${hue}, ${sat}%, ${light}%, ${c.opacity})`;
          ctx.fillText(c.char, c.x + c.offsetX, c.y + c.offsetY);
          
          // Ghost echo
          if (c.decay > 0.3) {
            ctx.fillStyle = `hsla(${hue}, ${sat}%, ${light}%, ${c.opacity * 0.2})`;
            ctx.fillText(c.char, c.x + c.offsetX + 2, c.y + c.offsetY + 2);
          }
        });
      }
    }
    
    function spawnMemory() {
      const text = phrases[Math.floor(Math.random() * phrases.length)];
      const x = 50 + Math.random() * (width - 300);
      const y = 80 + Math.random() * (height - 150);
      memories.push(new Memory(text, x, y));
    }
    
    // Initial memories
    for (let i = 0; i < 6; i++) {
      spawnMemory();
    }
    
    // Track cursor position over time for trailing effect
    let cursorHistory = [];
    
    function animate() {
      // Subtle fade
      ctx.fillStyle = 'rgba(10, 10, 10, 0.03)';
      ctx.fillRect(0, 0, width, height);
      
      input.tick();
      
      // Update cursor history
      cursorHistory.push({ x: input.rawX, y: input.rawY });
      if (cursorHistory.length > 30) cursorHistory.shift();
      
      // Update and draw memories
      memories = memories.filter(m => {
        // Use cursor history for broader decay field
        cursorHistory.forEach(pos => {
          m.update(pos.x, pos.y);
        });
        m.draw(ctx);
        return m.chars.some(c => c.intact);
      });
      
      // Spawn new memories
      if (Math.random() < 0.008 && memories.length < 10) {
        spawnMemory();
      }
      
      // Cursor glow (the observer)
      const gradient = ctx.createRadialGradient(
        input.rawX, input.rawY, 0,
        input.rawX, input.rawY, 60
      );
      gradient.addColorStop(0, 'rgba(255, 220, 180, 0.03)');
      gradient.addColorStop(1, 'transparent');
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(input.rawX, input.rawY, 60, 0, Math.PI * 2);
      ctx.fill();
      
      // Instruction (also fades)
      ctx.fillStyle = 'rgba(100, 100, 100, 0.2)';
      ctx.font = '11px monospace';
      ctx.fillText('observation degrades what it touches', 20, height - 20);
      
      requestAnimationFrame(animate);
    }
    
    // Tap spawns new memory
    input.on('tap', () => {
      if (memories.length < 12) {
        spawnMemory();
      }
    });
    
    animate();
  </script>
</body>
</html>
