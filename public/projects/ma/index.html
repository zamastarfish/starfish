<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>間 (ma)</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #f5f2eb;
    }
    
    canvas {
      display: block;
      width: 100%;
      height: 100%;
      cursor: default;
    }
    
    .character {
      position: fixed;
      top: 20px;
      right: 25px;
      font-family: "Hiragino Mincho Pro", "Yu Mincho", "MS Mincho", serif;
      font-size: 24px;
      color: rgba(60, 55, 50, 0.15);
      pointer-events: none;
      writing-mode: vertical-rl;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div class="character">間</div>

  <script>
    // 間 (ma) — the space between
    // Not emptiness. Pregnant pause.
    // The interval that gives meaning to what it separates.
    
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    let width, height;
    let marks = [];
    let time = 0;
    
    // Paper texture colors
    const paperBase = [245, 242, 235];
    const inkBase = [45, 42, 38];
    
    function resize() {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
      drawPaper();
    }
    
    resize();
    window.addEventListener('resize', resize);
    
    // Draw subtle paper texture
    function drawPaper() {
      ctx.fillStyle = `rgb(${paperBase.join(',')})`;
      ctx.fillRect(0, 0, width, height);
      
      // Very subtle noise texture
      const imageData = ctx.getImageData(0, 0, width, height);
      const data = imageData.data;
      
      for (let i = 0; i < data.length; i += 4) {
        const noise = (Math.random() - 0.5) * 8;
        data[i] = Math.min(255, Math.max(0, data[i] + noise));
        data[i + 1] = Math.min(255, Math.max(0, data[i + 1] + noise));
        data[i + 2] = Math.min(255, Math.max(0, data[i + 2] + noise));
      }
      
      ctx.putImageData(imageData, 0, 0);
    }
    
    // Ink mark — like sumi-e brush strokes
    class Mark {
      constructor(x, y, isAuto = false) {
        this.x = x;
        this.y = y;
        this.isAuto = isAuto;
        
        // Mark characteristics
        this.type = Math.random() < 0.7 ? 'dot' : (Math.random() < 0.5 ? 'stroke' : 'wash');
        
        if (this.type === 'dot') {
          this.size = isAuto ? 2 + Math.random() * 6 : 3 + Math.random() * 10;
        } else if (this.type === 'stroke') {
          this.length = 20 + Math.random() * 60;
          this.angle = Math.random() * Math.PI;
          this.width = 1 + Math.random() * 3;
        } else {
          this.size = 30 + Math.random() * 50;
        }
        
        // Opacity and life
        this.maxOpacity = isAuto ? 0.1 + Math.random() * 0.15 : 0.2 + Math.random() * 0.25;
        this.opacity = 0;
        this.targetOpacity = this.maxOpacity;
        this.fadeInSpeed = 0.02;
        
        // Marks fade over time - impermanence
        this.born = Date.now();
        this.lifespan = isAuto ? 15000 + Math.random() * 25000 : 20000 + Math.random() * 40000;
        
        this.drawn = false;
      }
      
      update() {
        const age = Date.now() - this.born;
        const life = age / this.lifespan;
        
        if (life < 0.2) {
          // Fade in
          this.opacity = Math.min(this.targetOpacity, this.opacity + this.fadeInSpeed);
        } else if (life > 0.6) {
          // Fade out
          this.opacity = this.maxOpacity * (1 - (life - 0.6) / 0.4);
        }
        
        return life < 1;
      }
      
      draw(ctx) {
        if (this.opacity <= 0) return;
        
        const alpha = this.opacity;
        
        if (this.type === 'dot') {
          // Ink dot - slightly irregular
          ctx.beginPath();
          
          const points = 8;
          for (let i = 0; i <= points; i++) {
            const angle = (i / points) * Math.PI * 2;
            const variance = 0.8 + Math.random() * 0.4;
            const r = this.size * variance;
            const px = this.x + Math.cos(angle) * r;
            const py = this.y + Math.sin(angle) * r;
            
            if (i === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
          }
          
          ctx.closePath();
          ctx.fillStyle = `rgba(${inkBase.join(',')}, ${alpha})`;
          ctx.fill();
          
        } else if (this.type === 'stroke') {
          // Brush stroke
          ctx.beginPath();
          
          const startX = this.x - Math.cos(this.angle) * this.length / 2;
          const startY = this.y - Math.sin(this.angle) * this.length / 2;
          const endX = this.x + Math.cos(this.angle) * this.length / 2;
          const endY = this.y + Math.sin(this.angle) * this.length / 2;
          
          // Vary width along stroke
          const segments = 10;
          ctx.moveTo(startX, startY);
          
          for (let i = 1; i <= segments; i++) {
            const t = i / segments;
            const x = startX + (endX - startX) * t;
            const y = startY + (endY - startY) * t;
            
            // Slight curve
            const perpX = -Math.sin(this.angle);
            const perpY = Math.cos(this.angle);
            const curve = Math.sin(t * Math.PI) * 3;
            
            ctx.lineTo(x + perpX * curve, y + perpY * curve);
          }
          
          ctx.strokeStyle = `rgba(${inkBase.join(',')}, ${alpha})`;
          ctx.lineWidth = this.width;
          ctx.lineCap = 'round';
          ctx.stroke();
          
        } else {
          // Ink wash - soft, diffuse
          const gradient = ctx.createRadialGradient(
            this.x, this.y, 0,
            this.x, this.y, this.size
          );
          gradient.addColorStop(0, `rgba(${inkBase.join(',')}, ${alpha * 0.5})`);
          gradient.addColorStop(0.5, `rgba(${inkBase.join(',')}, ${alpha * 0.2})`);
          gradient.addColorStop(1, 'transparent');
          
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
          ctx.fillStyle = gradient;
          ctx.fill();
        }
      }
    }
    
    // Sparse automatic marks
    function maybeAutoMark() {
      // Very infrequent — ma is about the space between
      if (Math.random() < 0.003 && marks.length < 12) {
        // Avoid edges and center — asymmetric placement
        const x = width * (0.15 + Math.random() * 0.7);
        const y = height * (0.15 + Math.random() * 0.7);
        
        marks.push(new Mark(x, y, true));
      }
    }
    
    function animate() {
      time++;
      
      // Redraw paper base (slow fade of marks)
      if (time % 3 === 0) {
        ctx.fillStyle = `rgba(${paperBase.join(',')}, 0.02)`;
        ctx.fillRect(0, 0, width, height);
      }
      
      // Update marks
      marks = marks.filter(m => m.update());
      
      // Draw marks
      marks.forEach(m => m.draw(ctx));
      
      // Maybe add automatic mark
      maybeAutoMark();
      
      requestAnimationFrame(animate);
    }
    
    // Interaction: add marks with intention
    let lastMark = 0;
    
    canvas.addEventListener('click', (e) => {
      const now = Date.now();
      if (now - lastMark < 800) return; // Deliberate pace
      lastMark = now;
      
      // Add mark at click position
      if (marks.length < 15) {
        marks.push(new Mark(e.clientX, e.clientY, false));
      }
    });
    
    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      const now = Date.now();
      if (now - lastMark < 800) return;
      lastMark = now;
      
      if (marks.length < 15) {
        marks.push(new Mark(touch.clientX, touch.clientY, false));
      }
    });
    
    // Start with mostly empty — one or two subtle marks
    setTimeout(() => {
      if (Math.random() < 0.6) {
        const x = width * (0.2 + Math.random() * 0.6);
        const y = height * (0.2 + Math.random() * 0.6);
        marks.push(new Mark(x, y, true));
      }
    }, 2000);
    
    drawPaper();
    animate();
    
    // The emptiness is not empty.
    // The silence is not silent.
    // Ma: the space that makes meaning possible.
    
  </script>
</body>
</html>
