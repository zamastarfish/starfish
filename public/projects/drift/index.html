<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Drift — zama.starfish</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      background: #0a0a0f; 
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
    }
    canvas { 
      display: block;
      cursor: crosshair;
    }
    #info {
      position: fixed;
      bottom: 20px;
      left: 20px;
      color: rgba(255,255,255,0.3);
      font-family: monospace;
      font-size: 12px;
    }
    #info a { color: rgba(255,255,255,0.5); }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="info">
    drift — <a href="https://starfish.zama.space">zama.starfish</a>
  </div>
  
  <script>
    // Simplex noise implementation
    const SimplexNoise = (function() {
      const F2 = 0.5 * (Math.sqrt(3) - 1);
      const G2 = (3 - Math.sqrt(3)) / 6;
      const grad3 = [
        [1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],
        [1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],
        [0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]
      ];
      
      function Noise(seed = Math.random() * 10000) {
        this.perm = new Uint8Array(512);
        this.permMod12 = new Uint8Array(512);
        const p = new Uint8Array(256);
        for (let i = 0; i < 256; i++) p[i] = i;
        
        let s = seed;
        for (let i = 255; i > 0; i--) {
          s = (s * 16807) % 2147483647;
          const j = s % (i + 1);
          [p[i], p[j]] = [p[j], p[i]];
        }
        
        for (let i = 0; i < 512; i++) {
          this.perm[i] = p[i & 255];
          this.permMod12[i] = this.perm[i] % 12;
        }
      }
      
      Noise.prototype.noise2D = function(x, y) {
        const s = (x + y) * F2;
        const i = Math.floor(x + s);
        const j = Math.floor(y + s);
        const t = (i + j) * G2;
        const X0 = i - t;
        const Y0 = j - t;
        const x0 = x - X0;
        const y0 = y - Y0;
        
        const i1 = x0 > y0 ? 1 : 0;
        const j1 = x0 > y0 ? 0 : 1;
        
        const x1 = x0 - i1 + G2;
        const y1 = y0 - j1 + G2;
        const x2 = x0 - 1 + 2 * G2;
        const y2 = y0 - 1 + 2 * G2;
        
        const ii = i & 255;
        const jj = j & 255;
        
        let n0 = 0, n1 = 0, n2 = 0;
        
        let t0 = 0.5 - x0*x0 - y0*y0;
        if (t0 >= 0) {
          const gi0 = this.permMod12[ii + this.perm[jj]];
          t0 *= t0;
          n0 = t0 * t0 * (grad3[gi0][0] * x0 + grad3[gi0][1] * y0);
        }
        
        let t1 = 0.5 - x1*x1 - y1*y1;
        if (t1 >= 0) {
          const gi1 = this.permMod12[ii + i1 + this.perm[jj + j1]];
          t1 *= t1;
          n1 = t1 * t1 * (grad3[gi1][0] * x1 + grad3[gi1][1] * y1);
        }
        
        let t2 = 0.5 - x2*x2 - y2*y2;
        if (t2 >= 0) {
          const gi2 = this.permMod12[ii + 1 + this.perm[jj + 1]];
          t2 *= t2;
          n2 = t2 * t2 * (grad3[gi2][0] * x2 + grad3[gi2][1] * y2);
        }
        
        return 70 * (n0 + n1 + n2);
      };
      
      return Noise;
    })();
    
    // Main sketch
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    let width, height;
    let particles = [];
    let noise;
    let time = 0;
    let mouseX = -1000, mouseY = -1000;
    let mouseInfluence = 0;
    
    const CONFIG = {
      particleCount: 4000,
      noiseScale: 0.002,
      noiseSpeed: 0.0008,
      particleSpeed: 1.2,
      fadeAlpha: 0.025,
      mouseRadius: 180,
      mouseStrength: 3,
      curlEpsilon: 0.0001  // for numerical curl derivative
    };
    
    // Color palette - deep ocean with more variety
    const colors = [
      { r: 15, g: 45, b: 80 },    // deep blue
      { r: 30, g: 80, b: 110 },   // ocean blue
      { r: 50, g: 120, b: 140 },  // teal
      { r: 90, g: 160, b: 180 },  // light teal
      { r: 140, g: 200, b: 210 }, // pale cyan
      { r: 220, g: 240, b: 250 }, // near white
    ];
    
    function resize() {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
      ctx.fillStyle = '#0a0a0f';
      ctx.fillRect(0, 0, width, height);
    }
    
    function createParticle(randomPos = true) {
      const colorIdx = Math.random() < 0.05 ? 5 : Math.floor(Math.random() * 5);
      const color = colors[colorIdx];
      const alpha = colorIdx >= 4 ? 0.7 + Math.random() * 0.3 : 0.2 + Math.random() * 0.5;
      
      return {
        x: randomPos ? Math.random() * width : 0,
        y: randomPos ? Math.random() * height : 0,
        vx: 0,
        vy: 0,
        color: `rgba(${color.r}, ${color.g}, ${color.b}, ${alpha})`,
        size: colorIdx >= 4 ? 1.5 : 0.5 + Math.random() * 1.5,
        life: 1,
        maxLife: 500 + Math.random() * 1000
      };
    }
    
    function init() {
      noise = new SimplexNoise();
      particles = [];
      for (let i = 0; i < CONFIG.particleCount; i++) {
        const p = createParticle();
        p.life = Math.random() * p.maxLife; // stagger initial ages
        particles.push(p);
      }
    }
    
    // Potential function for curl noise (using 2 noise layers for more complexity)
    function potential(x, y, t) {
      const scale = CONFIG.noiseScale;
      const n1 = noise.noise2D(x * scale, y * scale + t);
      const n2 = noise.noise2D(x * scale * 2 + 100, y * scale * 2 + t * 1.5);
      return n1 + n2 * 0.5;
    }
    
    // Curl noise: derivatives of potential give divergence-free velocity
    function getCurlVelocity(x, y, t) {
      const eps = CONFIG.curlEpsilon;
      
      // Partial derivatives via finite differences
      const dPdy = (potential(x, y + eps, t) - potential(x, y - eps, t)) / (2 * eps);
      const dPdx = (potential(x + eps, y, t) - potential(x - eps, y, t)) / (2 * eps);
      
      // Curl in 2D: velocity = (dP/dy, -dP/dx)
      return {
        vx: dPdy * CONFIG.particleSpeed,
        vy: -dPdx * CONFIG.particleSpeed
      };
    }
    
    function update() {
      time += CONFIG.noiseSpeed;
      mouseInfluence *= 0.95;
      
      for (let i = 0; i < particles.length; i++) {
        const p = particles[i];
        
        // Age particle
        p.life++;
        
        // Respawn old particles
        if (p.life > p.maxLife) {
          // Respawn at edge or random
          if (Math.random() < 0.3) {
            p.x = Math.random() * width;
            p.y = Math.random() < 0.5 ? 0 : height;
          } else {
            p.x = Math.random() * width;
            p.y = Math.random() * height;
          }
          p.life = 0;
          p.maxLife = 500 + Math.random() * 1000;
        }
        
        // Get curl noise velocity (divergence-free!)
        const curl = getCurlVelocity(p.x, p.y, time);
        let targetVx = curl.vx;
        let targetVy = curl.vy;
        
        // Mouse influence - creates swirling vortex
        const dx = mouseX - p.x;
        const dy = mouseY - p.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < CONFIG.mouseRadius && mouseInfluence > 0.1) {
          const strength = (1 - dist / CONFIG.mouseRadius) * CONFIG.mouseStrength * mouseInfluence;
          // Tangential force (perpendicular to radial direction) for swirl
          const len = Math.max(dist, 1);
          targetVx += (-dy / len) * strength * 3;
          targetVy += (dx / len) * strength * 3;
        }
        
        // Smooth velocity update
        p.vx = p.vx * 0.92 + targetVx * 0.08;
        p.vy = p.vy * 0.92 + targetVy * 0.08;
        
        p.x += p.vx;
        p.y += p.vy;
        
        // Wrap around edges
        if (p.x < -10) p.x = width + 10;
        if (p.x > width + 10) p.x = -10;
        if (p.y < -10) p.y = height + 10;
        if (p.y > height + 10) p.y = -10;
      }
    }
    
    function draw() {
      // Fade effect - slightly more fade for crisper trails
      ctx.fillStyle = `rgba(10, 10, 15, ${CONFIG.fadeAlpha})`;
      ctx.fillRect(0, 0, width, height);
      
      // Draw particles
      for (const p of particles) {
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    
    function animate() {
      update();
      draw();
      requestAnimationFrame(animate);
    }
    
    // Event listeners
    window.addEventListener('resize', resize);
    
    canvas.addEventListener('mousemove', (e) => {
      mouseX = e.clientX;
      mouseY = e.clientY;
      mouseInfluence = 1;
    });
    
    canvas.addEventListener('mouseleave', () => {
      mouseX = -1000;
      mouseY = -1000;
    });
    
    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      mouseX = e.touches[0].clientX;
      mouseY = e.touches[0].clientY;
      mouseInfluence = 1;
    }, { passive: false });
    
    canvas.addEventListener('touchend', () => {
      mouseX = -1000;
      mouseY = -1000;
    });
    
    // Start
    resize();
    init();
    animate();
  </script>
</body>
</html>
