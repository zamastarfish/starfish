<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Rain</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #2a3a4a;
      min-height: 100vh;
      overflow: hidden;
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }
  
    /* Navigation */
    .sf-nav { position: fixed; top: 20px; left: 20px; z-index: 1000; display: flex; gap: 12px; }
    .sf-nav a, .sf-nav button { 
      background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.1);
      color: rgba(255,255,255,0.4); text-decoration: none; font-size: 18px; 
      width: 36px; height: 36px; border-radius: 50%; display: flex; 
      align-items: center; justify-content: center; cursor: pointer;
      transition: all 0.3s; font-family: system-ui, sans-serif;
    }
    .sf-nav a:hover, .sf-nav button:hover { 
      background: rgba(0,0,0,0.5); color: rgba(255,255,255,0.8);
      border-color: rgba(255,255,255,0.3);
    }
    /* Modal */
    .sf-modal { 
      position: fixed; inset: 0; background: rgba(0,0,0,0.9); z-index: 2000;
      display: none; align-items: center; justify-content: center; padding: 20px;
    }
    .sf-modal.open { display: flex; }
    .sf-modal-content {
      background: #111; border: 1px solid #333; border-radius: 12px;
      max-width: 500px; width: 100%; max-height: 80vh; overflow-y: auto;
      padding: 30px; color: #ddd; font-family: system-ui, sans-serif;
    }
    .sf-modal h2 { margin: 0 0 20px; font-weight: 400; font-size: 24px; color: #fff; }
    .sf-modal h3 { margin: 20px 0 8px; font-weight: 500; font-size: 12px; 
      text-transform: uppercase; letter-spacing: 1px; color: #888; }
    .sf-modal p { margin: 0; line-height: 1.6; font-size: 15px; color: #aaa; }
    .sf-modal-close { 
      position: absolute; top: 20px; right: 20px; background: none; border: none;
      color: #666; font-size: 24px; cursor: pointer; padding: 10px;
    }
    .sf-modal-close:hover { color: #fff; }

  </style>
</head>
<body>

  <!-- Navigation -->
  <nav class="sf-nav">
    <a href="/" title="Back to gallery">←</a>
    <button onclick="document.getElementById('sf-modal').classList.add('open')" title="About this piece">?</button>
  </nav>
  
  <!-- Info Modal -->
  <div id="sf-modal" class="sf-modal" onclick="if(event.target===this)this.classList.remove('open')">
    <button class="sf-modal-close" onclick="document.getElementById('sf-modal').classList.remove('open')">×</button>
    <div class="sf-modal-content">
      <h2>Rain</h2>
      <h3>Concept</h3>
      <p>Droplets on glass. They gather, merge, race down. The blurry world outside.</p>
      <h3>Interaction</h3>
      <p>Watch the rain. Droplets form, merge, and stream down the glass.</p>
    </div>
  </div>

<canvas id="canvas"></canvas>
  
  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    let width, height;
    const droplets = [];
    const trails = [];
    
    function resize() {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
    }
    resize();
    window.addEventListener('resize', resize);
    
    // Droplet class
    class Droplet {
      constructor(x, y, r) {
        this.x = x;
        this.y = y;
        this.r = r || 2 + Math.random() * 4;
        this.vx = 0;
        this.vy = 0;
        this.stuck = true;
        this.stuckTime = 0;
        this.maxStuckTime = 1000 + Math.random() * 3000;
      }
      
      update(dt) {
        if (this.stuck) {
          // Grow slightly from accumulating mist
          this.r += 0.002 * dt;
          this.stuckTime += dt;
          
          // Eventually start falling if big enough
          if (this.r > 8 || this.stuckTime > this.maxStuckTime) {
            this.stuck = false;
            this.vy = 0.5;
          }
        } else {
          // Gravity + surface tension drag
          this.vy += 0.0003 * dt;
          this.vy = Math.min(this.vy, 0.3 + this.r * 0.02);
          
          // Slight horizontal wobble
          this.vx += (Math.random() - 0.5) * 0.01;
          this.vx *= 0.98;
          
          this.x += this.vx * dt * 0.05;
          this.y += this.vy * dt * 0.05;
          
          // Leave trail
          if (Math.random() < 0.1) {
            trails.push({
              x: this.x,
              y: this.y - this.r,
              r: 1 + Math.random() * 1.5,
              life: 1
            });
          }
          
          // Shrink slightly as we leave water behind
          this.r *= 0.9995;
        }
        
        return this.y < height + 50 && this.r > 0.5;
      }
      
      draw() {
        // Main droplet body
        const gradient = ctx.createRadialGradient(
          this.x - this.r * 0.3, this.y - this.r * 0.3, 0,
          this.x, this.y, this.r
        );
        gradient.addColorStop(0, 'rgba(255, 255, 255, 0.4)');
        gradient.addColorStop(0.5, 'rgba(200, 220, 240, 0.2)');
        gradient.addColorStop(1, 'rgba(150, 180, 210, 0.1)');
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        
        if (this.stuck) {
          // Round droplet when stuck
          ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
        } else {
          // Elongated when falling
          ctx.ellipse(this.x, this.y, this.r * 0.8, this.r * 1.2, 0, 0, Math.PI * 2);
        }
        ctx.fill();
        
        // Highlight
        ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
        ctx.beginPath();
        ctx.arc(this.x - this.r * 0.3, this.y - this.r * 0.3, this.r * 0.25, 0, Math.PI * 2);
        ctx.fill();
        
        // Refraction/lens effect (darker spot)
        ctx.fillStyle = 'rgba(60, 80, 100, 0.15)';
        ctx.beginPath();
        ctx.arc(this.x + this.r * 0.2, this.y + this.r * 0.2, this.r * 0.5, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    
    // Spawn initial droplets
    for (let i = 0; i < 80; i++) {
      droplets.push(new Droplet(
        Math.random() * width,
        Math.random() * height,
        2 + Math.random() * 6
      ));
    }
    
    // Check for droplet merging
    function checkMerge() {
      for (let i = droplets.length - 1; i >= 0; i--) {
        for (let j = i - 1; j >= 0; j--) {
          const a = droplets[i];
          const b = droplets[j];
          if (!a || !b) continue;
          
          const dx = a.x - b.x;
          const dy = a.y - b.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist < a.r + b.r) {
            // Merge into the larger one
            if (a.r > b.r) {
              a.r = Math.sqrt(a.r * a.r + b.r * b.r);
              a.x = (a.x * a.r + b.x * b.r) / (a.r + b.r);
              if (!a.stuck || !b.stuck) a.stuck = false;
              droplets.splice(j, 1);
            } else {
              b.r = Math.sqrt(a.r * a.r + b.r * b.r);
              b.x = (a.x * a.r + b.x * b.r) / (a.r + b.r);
              if (!a.stuck || !b.stuck) b.stuck = false;
              droplets.splice(i, 1);
            }
            break;
          }
        }
      }
    }
    
    // Draw blurry background (the world outside)
    function drawBackground() {
      // Gradient sky - moody, overcast
      const skyGrad = ctx.createLinearGradient(0, 0, 0, height);
      skyGrad.addColorStop(0, '#4a5568');
      skyGrad.addColorStop(0.5, '#718096');
      skyGrad.addColorStop(1, '#2d3748');
      ctx.fillStyle = skyGrad;
      ctx.fillRect(0, 0, width, height);
      
      // Blurry shapes suggesting buildings/trees
      ctx.fillStyle = 'rgba(30, 40, 50, 0.3)';
      for (let i = 0; i < 8; i++) {
        const x = (i / 8) * width + Math.sin(i * 3) * 50;
        const w = 60 + Math.sin(i * 2) * 40;
        const h = 150 + Math.sin(i * 1.5) * 100;
        ctx.fillRect(x, height - h, w, h);
      }
      
      // Distant lights (warm glows)
      for (let i = 0; i < 12; i++) {
        const x = Math.sin(i * 7) * width * 0.4 + width * 0.5;
        const y = height * 0.5 + Math.sin(i * 3) * height * 0.2;
        const gradient = ctx.createRadialGradient(x, y, 0, x, y, 30 + Math.sin(i) * 20);
        gradient.addColorStop(0, 'rgba(255, 200, 100, 0.15)');
        gradient.addColorStop(1, 'rgba(255, 200, 100, 0)');
        ctx.fillStyle = gradient;
        ctx.fillRect(x - 50, y - 50, 100, 100);
      }
      
      // Glass tint overlay
      ctx.fillStyle = 'rgba(100, 130, 160, 0.1)';
      ctx.fillRect(0, 0, width, height);
    }
    
    let lastTime = 0;
    
    function draw(time) {
      const dt = Math.min(time - lastTime, 50);
      lastTime = time;
      
      // Background
      drawBackground();
      
      // Update and draw trails (water marks left behind)
      for (let i = trails.length - 1; i >= 0; i--) {
        const t = trails[i];
        t.life -= 0.0005 * dt;
        
        if (t.life <= 0) {
          trails.splice(i, 1);
        } else {
          ctx.fillStyle = `rgba(200, 220, 240, ${t.life * 0.15})`;
          ctx.beginPath();
          ctx.arc(t.x, t.y, t.r, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      
      // Spawn new droplets (rain hitting window)
      if (Math.random() < 0.03) {
        droplets.push(new Droplet(
          Math.random() * width,
          Math.random() * height * 0.3
        ));
      }
      
      // Update and draw droplets
      for (let i = droplets.length - 1; i >= 0; i--) {
        const alive = droplets[i].update(dt);
        if (!alive) {
          droplets.splice(i, 1);
        }
      }
      
      // Check for merging
      checkMerge();
      
      // Draw all droplets
      droplets.forEach(d => d.draw());
      
      // Subtle vignette (window frame feeling)
      const vignette = ctx.createRadialGradient(
        width / 2, height / 2, height * 0.3,
        width / 2, height / 2, height * 0.8
      );
      vignette.addColorStop(0, 'rgba(0, 0, 0, 0)');
      vignette.addColorStop(1, 'rgba(0, 0, 0, 0.3)');
      ctx.fillStyle = vignette;
      ctx.fillRect(0, 0, width, height);
      
      requestAnimationFrame(draw);
    }
    
    draw(0);
  </script>
</body>
</html>
