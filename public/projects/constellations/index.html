<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Constellations</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #05080f;
      min-height: 100vh;
      overflow: hidden;
    }
    canvas { 
      display: block;
      width: 100vw;
      height: 100vh;
      cursor: crosshair;
    }
    
    .info {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(255, 255, 255, 0.25);
      font-family: system-ui, sans-serif;
      font-size: 0.75rem;
      text-align: center;
      pointer-events: none;
    }
    
    .controls {
      position: fixed;
      top: 20px;
      right: 20px;
      display: flex;
      gap: 8px;
    }
    
    .btn {
      color: rgba(255,255,255,0.3);
      background: transparent;
      border: 1px solid rgba(255,255,255,0.2);
      padding: 8px 16px;
      border-radius: 4px;
      font-family: system-ui, sans-serif;
      font-size: 0.75rem;
      cursor: pointer;
      transition: all 0.2s;
    }
    .btn:hover {
      color: rgba(255,255,255,0.6);
      border-color: rgba(255,255,255,0.4);
    }
    .btn:disabled {
      opacity: 0.3;
      cursor: not-allowed;
    }
    .btn:disabled:hover {
      color: rgba(255,255,255,0.3);
      border-color: rgba(255,255,255,0.2);
    }
    .btn.primary {
      background: rgba(100, 150, 255, 0.2);
      border-color: rgba(100, 150, 255, 0.4);
      color: rgba(200, 220, 255, 0.8);
    }
    .btn.primary:hover {
      background: rgba(100, 150, 255, 0.3);
      border-color: rgba(100, 150, 255, 0.6);
      color: rgba(200, 220, 255, 1);
    }
    .btn.primary:disabled {
      background: rgba(100, 150, 255, 0.1);
    }
    
    /* Overlay image - positioned to match constellation bounds */
    .constellation-overlay {
      position: fixed;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.5s ease;
      z-index: 50;
      background-size: contain;
      background-position: center;
      background-repeat: no-repeat;
      mix-blend-mode: screen;
    }
    .constellation-overlay.visible {
      opacity: 0.7;
    }
    .constellation-overlay.full {
      opacity: 1;
      mix-blend-mode: normal;
    }
    
    /* Story panel */
    .story-panel {
      position: fixed;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%) translateY(20px);
      background: rgba(10, 15, 25, 0.9);
      border: 1px solid rgba(100, 150, 255, 0.3);
      padding: 20px 30px;
      border-radius: 12px;
      max-width: 500px;
      text-align: center;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.4s, visibility 0.4s, transform 0.4s;
      z-index: 100;
    }
    .story-panel.visible {
      opacity: 1;
      visibility: visible;
      transform: translateX(-50%) translateY(0);
    }
    .story-panel h2 {
      color: rgba(200, 220, 255, 0.9);
      font-family: 'Georgia', serif;
      font-size: 1.5rem;
      font-weight: normal;
      font-style: italic;
      margin-bottom: 10px;
    }
    .story-panel p {
      color: rgba(255, 255, 255, 0.6);
      font-family: system-ui, sans-serif;
      font-size: 0.9rem;
      line-height: 1.6;
    }
    .story-panel .close-story {
      position: absolute;
      top: 10px;
      right: 15px;
      color: rgba(255,255,255,0.3);
      background: none;
      border: none;
      font-size: 18px;
      cursor: pointer;
      padding: 5px;
    }
    .story-panel .close-story:hover {
      color: rgba(255,255,255,0.6);
    }
    
    /* View toggle */
    .view-toggle {
      position: fixed;
      bottom: 20px;
      right: 20px;
      display: flex;
      gap: 8px;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s, visibility 0.3s;
      z-index: 100;
    }
    .view-toggle.visible {
      opacity: 1;
      visibility: visible;
    }
    
    /* Modal overlay */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(5, 8, 15, 0.9);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 2000;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s, visibility 0.3s;
    }
    .modal-overlay.visible {
      opacity: 1;
      visibility: visible;
    }
    
    .modal {
      max-width: 90vw;
      max-height: 90vh;
      position: relative;
    }
    
    .modal img {
      max-width: 100%;
      max-height: 85vh;
      border-radius: 8px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.5);
    }
    
    .modal-close {
      position: absolute;
      top: -40px;
      right: 0;
      color: rgba(255,255,255,0.5);
      background: transparent;
      border: none;
      font-size: 24px;
      cursor: pointer;
      padding: 8px;
      transition: color 0.2s;
    }
    .modal-close:hover {
      color: rgba(255,255,255,0.8);
    }
    
    .loading-overlay {
      position: fixed;
      inset: 0;
      background: rgba(5, 8, 15, 0.8);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1500;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s, visibility 0.3s;
    }
    .loading-overlay.visible {
      opacity: 1;
      visibility: visible;
    }
    
    .loading-text {
      color: rgba(200, 220, 255, 0.8);
      font-family: system-ui, sans-serif;
      font-size: 1rem;
      margin-top: 20px;
    }
    
    .spinner {
      width: 40px;
      height: 40px;
      border: 2px solid rgba(100, 150, 255, 0.2);
      border-top-color: rgba(100, 150, 255, 0.8);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    .error-toast {
      position: fixed;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%) translateY(20px);
      background: rgba(255, 100, 100, 0.2);
      border: 1px solid rgba(255, 100, 100, 0.4);
      color: rgba(255, 200, 200, 0.9);
      padding: 12px 24px;
      border-radius: 8px;
      font-family: system-ui, sans-serif;
      font-size: 0.875rem;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s, visibility 0.3s, transform 0.3s;
      z-index: 1500;
    }
    .error-toast.visible {
      opacity: 1;
      visibility: visible;
      transform: translateX(-50%) translateY(0);
    }
  
    /* Navigation */
    .sf-nav { position: fixed; top: 20px; left: 20px; z-index: 1000; display: flex; gap: 12px; }
    .sf-nav a, .sf-nav button { 
      background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.1);
      color: rgba(255,255,255,0.4); text-decoration: none; font-size: 18px; 
      width: 36px; height: 36px; border-radius: 50%; display: flex; 
      align-items: center; justify-content: center; cursor: pointer;
      transition: all 0.3s; font-family: system-ui, sans-serif;
    }
    .sf-nav a:hover, .sf-nav button:hover { 
      background: rgba(0,0,0,0.5); color: rgba(255,255,255,0.8);
      border-color: rgba(255,255,255,0.3);
    }
    /* Modal */
    .sf-modal { 
      position: fixed; inset: 0; background: rgba(0,0,0,0.9); z-index: 2000;
      display: none; align-items: center; justify-content: center; padding: 20px;
    }
    .sf-modal.open { display: flex; }
    .sf-modal-content {
      background: #111; border: 1px solid #333; border-radius: 12px;
      max-width: 500px; width: 100%; max-height: 80vh; overflow-y: auto;
      padding: 30px; color: #ddd; font-family: system-ui, sans-serif;
    }
    .sf-modal h2 { margin: 0 0 20px; font-weight: 400; font-size: 24px; color: #fff; }
    .sf-modal h3 { margin: 20px 0 8px; font-weight: 500; font-size: 12px; 
      text-transform: uppercase; letter-spacing: 1px; color: #888; }
    .sf-modal p { margin: 0; line-height: 1.6; font-size: 15px; color: #aaa; }
    .sf-modal-close { 
      position: absolute; top: 20px; right: 20px; background: none; border: none;
      color: #666; font-size: 24px; cursor: pointer; padding: 10px;
    }
    .sf-modal-close:hover { color: #fff; }

  </style>
</head>
<body>

  <!-- Navigation -->
  <nav class="sf-nav">
    <a href="/" title="Back to gallery">←</a>
    <button onclick="document.getElementById('sf-modal').classList.add('open')" title="About this piece">?</button>
  </nav>
  
  <!-- Info Modal -->
  <div id="sf-modal" class="sf-modal" onclick="if(event.target===this)this.classList.remove('open')">
    <button class="sf-modal-close" onclick="document.getElementById('sf-modal').classList.remove('open')">×</button>
    <div class="sf-modal-content">
      <h2>Constellations</h2>
      <h3>Concept</h3>
      <p>Draw your own myths. Connect stars, tell stories about randomness.</p>
      <h3>Interaction</h3>
      <p>Click and drag between stars to draw lines. Create your own constellations.</p>
    </div>
  </div>

<div class="controls">
    <button class="btn primary" id="imagineBtn" disabled>Imagine</button>
    <button class="btn" id="undoBtn" disabled>Undo</button>
    <button class="btn" id="clearBtn">Clear</button>
  </div>
  <canvas id="canvas"></canvas>
  <div class="constellation-overlay" id="constellationOverlay"></div>
  <div class="info">Click stars to connect them — keep clicking to draw your myth</div>
  
  <div class="story-panel" id="storyPanel">
    <button class="close-story" id="closeStory">×</button>
    <h2 id="storyTitle"></h2>
    <p id="storyText"></p>
  </div>
  
  <div class="view-toggle" id="viewToggle">
    <button class="btn" id="toggleOverlay">Show Art</button>
    <button class="btn" id="viewFull">View Full</button>
  </div>
  
  <div class="loading-overlay" id="loadingOverlay">
    <div class="spinner"></div>
    <div class="loading-text">Imagining your constellation...</div>
  </div>
  
  <div class="modal-overlay" id="modalOverlay">
    <div class="modal">
      <button class="modal-close" id="modalClose">×</button>
      <img id="generatedImage" src="" alt="Generated constellation art">
    </div>
  </div>
  
  <div class="error-toast" id="errorToast"></div>
  
  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const clearBtn = document.getElementById('clearBtn');
    const undoBtn = document.getElementById('undoBtn');
    const imagineBtn = document.getElementById('imagineBtn');
    const loadingOverlay = document.getElementById('loadingOverlay');
    const modalOverlay = document.getElementById('modalOverlay');
    const modalClose = document.getElementById('modalClose');
    const generatedImage = document.getElementById('generatedImage');
    const errorToast = document.getElementById('errorToast');
    const constellationOverlay = document.getElementById('constellationOverlay');
    const storyPanel = document.getElementById('storyPanel');
    const storyTitle = document.getElementById('storyTitle');
    const storyText = document.getElementById('storyText');
    const closeStory = document.getElementById('closeStory');
    const viewToggle = document.getElementById('viewToggle');
    const toggleOverlay = document.getElementById('toggleOverlay');
    const viewFull = document.getElementById('viewFull');
    
    let width, height;
    const stars = [];
    const lines = [];
    let selectedStar = null;
    let mouseX = 0, mouseY = 0;
    let isGenerating = false;
    let currentGeneratedImage = null;
    let overlayVisible = false;
    
    function resize() {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
      
      if (stars.length === 0) {
        generateStars();
      }
    }
    
    function generateStars() {
      stars.length = 0;
      lines.length = 0;
      
      const numStars = Math.floor((width * height) / 8000);
      
      for (let i = 0; i < numStars; i++) {
        stars.push({
          x: Math.random() * width,
          y: Math.random() * height,
          size: Math.random() < 0.1 ? 2 + Math.random() * 2 : 1 + Math.random(),
          brightness: 0.5 + Math.random() * 0.5,
          twinkleSpeed: 0.002 + Math.random() * 0.005,
          twinklePhase: Math.random() * Math.PI * 2
        });
      }
    }
    
    resize();
    window.addEventListener('resize', resize);
    
    function findNearestStar(x, y, maxDist = 30) {
      let nearest = null;
      let nearestDist = maxDist;
      
      for (const star of stars) {
        const dx = star.x - x;
        const dy = star.y - y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < nearestDist) {
          nearest = star;
          nearestDist = dist;
        }
      }
      
      return nearest;
    }
    
    function updateButtons() {
      undoBtn.disabled = lines.length === 0;
      imagineBtn.disabled = lines.length < 2 || isGenerating;
    }
    
    function showError(message) {
      errorToast.textContent = message;
      errorToast.classList.add('visible');
      setTimeout(() => {
        errorToast.classList.remove('visible');
      }, 4000);
    }
    
    function getConstellationStars() {
      const starIndices = new Set();
      for (const line of lines) {
        const aIndex = stars.indexOf(line.a);
        const bIndex = stars.indexOf(line.b);
        if (aIndex !== -1) starIndices.add(aIndex);
        if (bIndex !== -1) starIndices.add(bIndex);
      }
      return Array.from(starIndices);
    }
    
    // Get bounding box of constellation - SQUARE with padding
    function getConstellationBounds(padding = 60) {
      const constellationStarIndices = getConstellationStars();
      if (constellationStarIndices.length === 0) return null;
      
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      
      for (const idx of constellationStarIndices) {
        const star = stars[idx];
        minX = Math.min(minX, star.x);
        minY = Math.min(minY, star.y);
        maxX = Math.max(maxX, star.x);
        maxY = Math.max(maxY, star.y);
      }
      
      // Calculate center and make it square
      const centerX = (minX + maxX) / 2;
      const centerY = (minY + maxY) / 2;
      const sizeX = maxX - minX;
      const sizeY = maxY - minY;
      
      // Use the larger dimension to make a square, plus padding
      const size = Math.max(sizeX, sizeY) + padding * 2;
      
      // Calculate square bounds centered on constellation
      let squareMinX = centerX - size / 2;
      let squareMinY = centerY - size / 2;
      let squareMaxX = centerX + size / 2;
      let squareMaxY = centerY + size / 2;
      
      // Clamp to canvas bounds, but try to maintain square
      if (squareMinX < 0) {
        squareMaxX -= squareMinX;
        squareMinX = 0;
      }
      if (squareMinY < 0) {
        squareMaxY -= squareMinY;
        squareMinY = 0;
      }
      if (squareMaxX > width) {
        squareMinX -= (squareMaxX - width);
        squareMaxX = width;
      }
      if (squareMaxY > height) {
        squareMinY -= (squareMaxY - height);
        squareMaxY = height;
      }
      
      // Final clamp
      squareMinX = Math.max(0, squareMinX);
      squareMinY = Math.max(0, squareMinY);
      squareMaxX = Math.min(width, squareMaxX);
      squareMaxY = Math.min(height, squareMaxY);
      
      return { 
        minX: squareMinX, 
        minY: squareMinY, 
        maxX: squareMaxX, 
        maxY: squareMaxY, 
        width: squareMaxX - squareMinX, 
        height: squareMaxY - squareMinY 
      };
    }
    
    // Store current bounds for overlay positioning
    let currentBounds = null;
    
    // Capture constellation as image (cropped to bounds)
    function captureConstellationImage() {
      const bounds = getConstellationBounds(80);
      if (!bounds) return null;
      
      currentBounds = bounds;
      
      // Create a canvas cropped to constellation bounds
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = bounds.width;
      tempCanvas.height = bounds.height;
      const tempCtx = tempCanvas.getContext('2d');
      
      // Dark background
      tempCtx.fillStyle = '#05080f';
      tempCtx.fillRect(0, 0, bounds.width, bounds.height);
      
      // Offset for cropping
      const offsetX = bounds.minX;
      const offsetY = bounds.minY;
      
      // Draw constellation lines
      tempCtx.strokeStyle = 'rgba(100, 150, 255, 0.8)';
      tempCtx.lineWidth = 2;
      
      for (const line of lines) {
        tempCtx.beginPath();
        tempCtx.moveTo(line.a.x - offsetX, line.a.y - offsetY);
        tempCtx.lineTo(line.b.x - offsetX, line.b.y - offsetY);
        tempCtx.stroke();
      }
      
      // Draw constellation stars (brighter)
      const constellationStarIndices = new Set(getConstellationStars());
      for (let i = 0; i < stars.length; i++) {
        const star = stars[i];
        if (constellationStarIndices.has(i)) {
          const sx = star.x - offsetX;
          const sy = star.y - offsetY;
          
          // Constellation star - bright
          tempCtx.fillStyle = 'rgba(255, 255, 255, 1)';
          tempCtx.beginPath();
          tempCtx.arc(sx, sy, star.size * 2, 0, Math.PI * 2);
          tempCtx.fill();
          
          // Glow
          const glow = tempCtx.createRadialGradient(sx, sy, 0, sx, sy, star.size * 6);
          glow.addColorStop(0, 'rgba(200, 220, 255, 0.5)');
          glow.addColorStop(1, 'rgba(200, 220, 255, 0)');
          tempCtx.fillStyle = glow;
          tempCtx.beginPath();
          tempCtx.arc(sx, sy, star.size * 6, 0, Math.PI * 2);
          tempCtx.fill();
        }
      }
      
      return tempCanvas.toDataURL('image/png');
    }
    
    // Position overlay to match constellation bounds
    function positionOverlay() {
      if (!currentBounds) return;
      
      constellationOverlay.style.left = currentBounds.minX + 'px';
      constellationOverlay.style.top = currentBounds.minY + 'px';
      constellationOverlay.style.width = currentBounds.width + 'px';
      constellationOverlay.style.height = currentBounds.height + 'px';
    }
    
    async function generateImage() {
      if (lines.length < 2 || isGenerating) return;
      
      isGenerating = true;
      updateButtons();
      loadingOverlay.classList.add('visible');
      
      // Hide previous overlay/story
      constellationOverlay.classList.remove('visible', 'full');
      storyPanel.classList.remove('visible');
      viewToggle.classList.remove('visible');
      
      try {
        // Capture the constellation as an image
        const canvasImage = captureConstellationImage();
        
        // Collect constellation data
        const constellationStarIndices = getConstellationStars();
        const constellationStars = constellationStarIndices.map(i => ({
          x: stars[i].x,
          y: stars[i].y
        }));
        
        const indexMap = new Map();
        constellationStarIndices.forEach((globalIdx, localIdx) => {
          indexMap.set(globalIdx, localIdx);
        });
        
        const constellationLines = lines.map(line => ({
          a: indexMap.get(stars.indexOf(line.a)),
          b: indexMap.get(stars.indexOf(line.b))
        }));
        
        const response = await fetch('/api/imagine', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            constellation: {
              stars: constellationStars,
              lines: constellationLines,
              width,
              height
            },
            canvasImage
          })
        });
        
        const data = await response.json();
        
        if (!response.ok) {
          throw new Error(data.error || 'Failed to generate image');
        }
        
        // Store and display the generated image
        currentGeneratedImage = data.image;
        generatedImage.src = data.image;
        constellationOverlay.style.backgroundImage = `url(${data.image})`;
        positionOverlay();
        
        // Update story panel
        if (data.title) {
          storyTitle.textContent = data.title;
          storyText.textContent = data.story || '';
          storyPanel.classList.add('visible');
        }
        
        // Show view toggle
        viewToggle.classList.add('visible');
        overlayVisible = false;
        toggleOverlay.textContent = 'Show Art';
        
        loadingOverlay.classList.remove('visible');
        
      } catch (error) {
        console.error('Generation error:', error);
        loadingOverlay.classList.remove('visible');
        showError(error.message || 'Failed to generate image. Please try again.');
      } finally {
        isGenerating = false;
        updateButtons();
      }
    }
    
    // Mouse handling
    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);
      mouseY = (e.clientY - rect.top) * (canvas.height / rect.height);
    });
    
    canvas.addEventListener('click', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (canvas.width / rect.width);
      const y = (e.clientY - rect.top) * (canvas.height / rect.height);
      
      const clickedStar = findNearestStar(x, y);
      
      if (clickedStar) {
        if (selectedStar && selectedStar !== clickedStar) {
          const exists = lines.some(line => 
            (line.a === selectedStar && line.b === clickedStar) ||
            (line.a === clickedStar && line.b === selectedStar)
          );
          
          if (!exists) {
            lines.push({ a: selectedStar, b: clickedStar });
            updateButtons();
          }
          selectedStar = clickedStar;
        } else if (selectedStar === clickedStar) {
          selectedStar = null;
        } else {
          selectedStar = clickedStar;
        }
      } else {
        selectedStar = null;
      }
    });
    
    // Touch support
    canvas.addEventListener('touchend', (e) => {
      e.preventDefault();
      const touch = e.changedTouches[0];
      const rect = canvas.getBoundingClientRect();
      const x = (touch.clientX - rect.left) * (canvas.width / rect.width);
      const y = (touch.clientY - rect.top) * (canvas.height / rect.height);
      
      const clickedStar = findNearestStar(x, y, 40);
      
      if (clickedStar) {
        if (selectedStar && selectedStar !== clickedStar) {
          const exists = lines.some(line => 
            (line.a === selectedStar && line.b === clickedStar) ||
            (line.a === clickedStar && line.b === selectedStar)
          );
          
          if (!exists) {
            lines.push({ a: selectedStar, b: clickedStar });
            updateButtons();
          }
          selectedStar = clickedStar;
        } else if (selectedStar === clickedStar) {
          selectedStar = null;
        } else {
          selectedStar = clickedStar;
        }
      } else {
        selectedStar = null;
      }
    }, { passive: false });
    
    // Imagine button
    imagineBtn.addEventListener('click', generateImage);
    
    // Undo button
    undoBtn.addEventListener('click', () => {
      if (lines.length > 0) {
        lines.pop();
        updateButtons();
        selectedStar = null;
      }
    });
    
    // Clear button
    clearBtn.addEventListener('click', () => {
      lines.length = 0;
      selectedStar = null;
      updateButtons();
      // Hide overlay and story
      constellationOverlay.classList.remove('visible', 'full');
      storyPanel.classList.remove('visible');
      viewToggle.classList.remove('visible');
      currentGeneratedImage = null;
    });
    
    // View controls
    toggleOverlay.addEventListener('click', () => {
      overlayVisible = !overlayVisible;
      if (overlayVisible) {
        constellationOverlay.classList.add('visible');
        constellationOverlay.classList.remove('full');
        toggleOverlay.textContent = 'Hide Art';
      } else {
        constellationOverlay.classList.remove('visible');
        toggleOverlay.textContent = 'Show Art';
      }
    });
    
    viewFull.addEventListener('click', () => {
      if (currentGeneratedImage) {
        modalOverlay.classList.add('visible');
      }
    });
    
    // Close story panel
    closeStory.addEventListener('click', () => {
      storyPanel.classList.remove('visible');
    });
    
    // Modal close
    modalClose.addEventListener('click', () => {
      modalOverlay.classList.remove('visible');
    });
    
    modalOverlay.addEventListener('click', (e) => {
      if (e.target === modalOverlay) {
        modalOverlay.classList.remove('visible');
      }
    });
    
    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if ((e.metaKey || e.ctrlKey) && e.key === 'z') {
        e.preventDefault();
        if (lines.length > 0) {
          lines.pop();
          updateButtons();
          selectedStar = null;
        }
      }
      if (e.key === 'Escape') {
        selectedStar = null;
        modalOverlay.classList.remove('visible');
      }
      if ((e.metaKey || e.ctrlKey) && e.key === 'Enter') {
        e.preventDefault();
        generateImage();
      }
      // Toggle overlay with 'o' key
      if (e.key === 'o' && currentGeneratedImage) {
        toggleOverlay.click();
      }
    });
    
    function draw(time) {
      // Night sky gradient
      const skyGrad = ctx.createLinearGradient(0, 0, 0, height);
      skyGrad.addColorStop(0, '#05080f');
      skyGrad.addColorStop(0.5, '#0a1020');
      skyGrad.addColorStop(1, '#0f1525');
      ctx.fillStyle = skyGrad;
      ctx.fillRect(0, 0, width, height);
      
      // Draw faint background stars
      ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
      for (let i = 0; i < 200; i++) {
        const x = (Math.sin(i * 456.789) * 0.5 + 0.5) * width;
        const y = (Math.cos(i * 123.456) * 0.5 + 0.5) * height;
        ctx.beginPath();
        ctx.arc(x, y, 0.5, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Draw constellation lines
      ctx.strokeStyle = 'rgba(100, 150, 255, 0.4)';
      ctx.lineWidth = 1;
      
      for (const line of lines) {
        ctx.beginPath();
        ctx.moveTo(line.a.x, line.a.y);
        ctx.lineTo(line.b.x, line.b.y);
        ctx.stroke();
      }
      
      // Draw line in progress
      if (selectedStar) {
        const hoverStar = findNearestStar(mouseX, mouseY);
        const targetX = hoverStar ? hoverStar.x : mouseX;
        const targetY = hoverStar ? hoverStar.y : mouseY;
        
        ctx.strokeStyle = 'rgba(100, 150, 255, 0.3)';
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(selectedStar.x, selectedStar.y);
        ctx.lineTo(targetX, targetY);
        ctx.stroke();
        ctx.setLineDash([]);
      }
      
      // Draw stars
      for (const star of stars) {
        const twinkle = Math.sin(time * star.twinkleSpeed + star.twinklePhase);
        const brightness = star.brightness * (0.7 + twinkle * 0.3);
        
        const glowSize = star.size * 3;
        const glow = ctx.createRadialGradient(
          star.x, star.y, 0,
          star.x, star.y, glowSize
        );
        glow.addColorStop(0, `rgba(200, 220, 255, ${brightness * 0.3})`);
        glow.addColorStop(1, 'rgba(200, 220, 255, 0)');
        ctx.fillStyle = glow;
        ctx.beginPath();
        ctx.arc(star.x, star.y, glowSize, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = `rgba(255, 255, 255, ${brightness})`;
        ctx.beginPath();
        ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Highlight selected star
      if (selectedStar) {
        ctx.strokeStyle = 'rgba(100, 150, 255, 0.8)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(selectedStar.x, selectedStar.y, 15, 0, Math.PI * 2);
        ctx.stroke();
      }
      
      // Highlight hovered star
      const hoverStar = findNearestStar(mouseX, mouseY);
      if (hoverStar && hoverStar !== selectedStar) {
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(hoverStar.x, hoverStar.y, 12, 0, Math.PI * 2);
        ctx.stroke();
      }
      
      requestAnimationFrame(draw);
    }
    
    draw(0);
  </script>
</body>
</html>
