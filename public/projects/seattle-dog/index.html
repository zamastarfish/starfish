<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Seattle Dog</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-family: system-ui, -apple-system, sans-serif;
      overflow: hidden;
    }
    canvas {
      max-width: 100%;
      max-height: 80vh;
    }
    .caption {
      color: #e94560;
      font-size: 0.9rem;
      margin-top: 1.5rem;
      text-transform: uppercase;
      letter-spacing: 0.2em;
      opacity: 0.8;
    }
    .time {
      color: #ffffff33;
      font-size: 0.75rem;
      margin-top: 0.5rem;
      font-variant-numeric: tabular-nums;
    }
  .back-btn { position: fixed; top: 20px; left: 20px; color: rgba(255,255,255,0.4); text-decoration: none; font-size: 24px; z-index: 1000; transition: color 0.2s; line-height: 1; } .back-btn:hover { color: rgba(255,255,255,0.8); }
  </style>
</head>
<body>
  <a href="/" class="back-btn">←</a>
  <canvas id="canvas" width="800" height="600"></canvas>
  <div class="caption">Seattle Dog</div>
  <div class="time">2:47 AM • Outside the bar</div>
  
  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    // Rain drops
    const drops = [];
    for (let i = 0; i < 200; i++) {
      drops.push({
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        speed: 4 + Math.random() * 6,
        length: 10 + Math.random() * 20
      });
    }
    
    // Steam particles
    const steam = [];
    for (let i = 0; i < 30; i++) {
      steam.push({
        x: 400 + (Math.random() - 0.5) * 200,
        y: 350,
        vx: (Math.random() - 0.5) * 0.5,
        vy: -0.5 - Math.random() * 1,
        life: Math.random(),
        maxLife: 0.5 + Math.random() * 0.5
      });
    }
    
    // Onion pieces (generative)
    const onions = [];
    for (let i = 0; i < 25; i++) {
      onions.push({
        x: 280 + Math.random() * 240,
        y: 295 + Math.random() * 30,
        width: 15 + Math.random() * 25,
        curl: Math.random() * Math.PI * 2,
        golden: 0.3 + Math.random() * 0.7
      });
    }
    
    // Cream cheese drips
    const drips = [];
    for (let i = 0; i < 8; i++) {
      drips.push({
        x: 300 + i * 30 + Math.random() * 10,
        length: 10 + Math.random() * 25,
        phase: Math.random() * Math.PI * 2
      });
    }
    
    // Neon flicker
    let neonIntensity = 1;
    let neonTarget = 1;
    
    function drawRain() {
      ctx.strokeStyle = 'rgba(150, 180, 255, 0.3)';
      ctx.lineWidth = 1;
      
      drops.forEach(drop => {
        ctx.beginPath();
        ctx.moveTo(drop.x, drop.y);
        ctx.lineTo(drop.x - 2, drop.y + drop.length);
        ctx.stroke();
        
        drop.y += drop.speed;
        drop.x -= 0.5;
        
        if (drop.y > canvas.height) {
          drop.y = -drop.length;
          drop.x = Math.random() * canvas.width;
        }
      });
    }
    
    function drawNeonGlow() {
      // Update flicker
      if (Math.random() < 0.02) {
        neonTarget = 0.6 + Math.random() * 0.4;
      }
      neonIntensity += (neonTarget - neonIntensity) * 0.1;
      
      const intensity = Math.floor(neonIntensity * 255);
      
      // Pink neon reflection on wet ground
      const gradient = ctx.createLinearGradient(0, 500, 0, 600);
      gradient.addColorStop(0, `rgba(233, 69, 96, ${0.1 * neonIntensity})`);
      gradient.addColorStop(1, 'rgba(233, 69, 96, 0)');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 500, canvas.width, 100);
    }
    
    function drawCart() {
      // Cart body - simple, iconic
      ctx.fillStyle = '#2d2d44';
      ctx.fillRect(200, 350, 400, 150);
      
      // Cart top / umbrella
      ctx.fillStyle = '#e94560';
      ctx.beginPath();
      ctx.moveTo(150, 200);
      ctx.lineTo(400, 150);
      ctx.lineTo(650, 200);
      ctx.lineTo(600, 210);
      ctx.lineTo(400, 170);
      ctx.lineTo(200, 210);
      ctx.closePath();
      ctx.fill();
      
      // Umbrella drips
      ctx.fillStyle = 'rgba(150, 180, 255, 0.5)';
      for (let i = 0; i < 5; i++) {
        const x = 180 + i * 100;
        const dripY = 210 + Math.sin(Date.now() / 500 + i) * 5;
        ctx.beginPath();
        ctx.ellipse(x, dripY, 2, 4, 0, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Grill surface
      ctx.fillStyle = '#1a1a28';
      ctx.fillRect(250, 280, 300, 80);
      
      // Grill glow
      const grillGlow = ctx.createRadialGradient(400, 320, 0, 400, 320, 150);
      grillGlow.addColorStop(0, 'rgba(255, 120, 50, 0.2)');
      grillGlow.addColorStop(1, 'rgba(255, 120, 50, 0)');
      ctx.fillStyle = grillGlow;
      ctx.fillRect(250, 250, 300, 120);
    }
    
    function drawBun() {
      // Bottom bun
      ctx.fillStyle = '#c9a66b';
      ctx.beginPath();
      ctx.ellipse(400, 340, 120, 25, 0, 0, Math.PI);
      ctx.fill();
      
      // Top bun
      ctx.fillStyle = '#dbb678';
      ctx.beginPath();
      ctx.ellipse(400, 300, 115, 22, 0, Math.PI, Math.PI * 2);
      ctx.fill();
      
      // Bun highlight
      ctx.fillStyle = '#e8c88a';
      ctx.beginPath();
      ctx.ellipse(400, 295, 80, 12, 0, Math.PI, Math.PI * 2);
      ctx.fill();
    }
    
    function drawHotDog() {
      // The dog itself
      const gradient = ctx.createLinearGradient(280, 300, 280, 340);
      gradient.addColorStop(0, '#c44536');
      gradient.addColorStop(0.5, '#8b2500');
      gradient.addColorStop(1, '#c44536');
      
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.ellipse(400, 318, 115, 18, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Grill marks
      ctx.strokeStyle = '#5c1a0a';
      ctx.lineWidth = 3;
      for (let i = 0; i < 6; i++) {
        const x = 310 + i * 30;
        ctx.beginPath();
        ctx.moveTo(x, 308);
        ctx.lineTo(x + 5, 328);
        ctx.stroke();
      }
    }
    
    function drawCreamCheese(time) {
      ctx.fillStyle = '#f5f5f0';
      
      // Main cream cheese line
      ctx.beginPath();
      ctx.moveTo(290, 315);
      
      // Wavy cream cheese
      for (let x = 290; x <= 510; x += 5) {
        const wave = Math.sin(x * 0.05 + time * 0.002) * 3;
        ctx.lineTo(x, 312 + wave);
      }
      
      ctx.lineTo(510, 320);
      ctx.lineTo(290, 320);
      ctx.closePath();
      ctx.fill();
      
      // Drips - the iconic cream cheese drip
      drips.forEach(drip => {
        const wobble = Math.sin(time * 0.003 + drip.phase) * 2;
        const currentLength = drip.length + Math.sin(time * 0.001 + drip.phase) * 5;
        
        ctx.beginPath();
        ctx.moveTo(drip.x - 4, 318);
        ctx.quadraticCurveTo(
          drip.x + wobble, 318 + currentLength * 0.5,
          drip.x - 2, 318 + currentLength
        );
        ctx.quadraticCurveTo(
          drip.x, 318 + currentLength + 5,
          drip.x + 2, 318 + currentLength
        );
        ctx.quadraticCurveTo(
          drip.x + 4 + wobble, 318 + currentLength * 0.5,
          drip.x + 4, 318
        );
        ctx.closePath();
        ctx.fill();
      });
    }
    
    function drawOnions(time) {
      onions.forEach((onion, i) => {
        // Caramelized onion color based on 'golden' factor
        const r = Math.floor(180 + onion.golden * 60);
        const g = Math.floor(120 + onion.golden * 80);
        const b = Math.floor(40 + onion.golden * 30);
        ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
        
        ctx.save();
        ctx.translate(onion.x, onion.y);
        ctx.rotate(onion.curl + Math.sin(time * 0.001 + i) * 0.05);
        
        // Curled onion strand
        ctx.beginPath();
        ctx.ellipse(0, 0, onion.width, 4, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Slight highlight
        ctx.fillStyle = `rgba(255, 255, 200, ${0.2 * onion.golden})`;
        ctx.beginPath();
        ctx.ellipse(-onion.width * 0.3, -1, onion.width * 0.4, 2, 0, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
      });
    }
    
    function drawSteam(time) {
      steam.forEach(particle => {
        particle.x += particle.vx + Math.sin(time * 0.002 + particle.x) * 0.3;
        particle.y += particle.vy;
        particle.life += 0.005;
        
        if (particle.life > particle.maxLife) {
          particle.x = 400 + (Math.random() - 0.5) * 200;
          particle.y = 320;
          particle.life = 0;
          particle.vx = (Math.random() - 0.5) * 0.5;
        }
        
        const alpha = Math.max(0, 1 - particle.life / particle.maxLife) * 0.3;
        const size = 5 + particle.life * 20;
        
        ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
        ctx.beginPath();
        ctx.arc(particle.x, particle.y, size, 0, Math.PI * 2);
        ctx.fill();
      });
    }
    
    function draw() {
      const time = Date.now();
      
      // Clear with night sky
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Rain (behind everything)
      drawRain();
      
      // Neon glow on ground
      drawNeonGlow();
      
      // The cart
      drawCart();
      
      // Steam rising
      drawSteam(time);
      
      // The star: Seattle Dog
      drawBun();
      drawHotDog();
      drawCreamCheese(time);
      drawOnions(time);
      
      requestAnimationFrame(draw);
    }
    
    draw();
  </script>
</body>
</html>
