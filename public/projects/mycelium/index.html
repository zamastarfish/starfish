<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mycelium</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1612;
      min-height: 100vh;
      overflow: hidden;
    }
    canvas { 
      display: block;
      width: 100vw;
      height: 100vh;
      cursor: crosshair;
    }
    
    .info {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(255, 250, 240, 0.3);
      font-family: system-ui, sans-serif;
      font-size: 0.75rem;
      text-align: center;
    }
  
    /* Navigation */
    .sf-nav { position: fixed; top: 20px; left: 20px; z-index: 1000; display: flex; gap: 12px; }
    .sf-nav a, .sf-nav button { 
      background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.1);
      color: rgba(255,255,255,0.4); text-decoration: none; font-size: 18px; 
      width: 36px; height: 36px; border-radius: 50%; display: flex; 
      align-items: center; justify-content: center; cursor: pointer;
      transition: all 0.3s; font-family: system-ui, sans-serif;
    }
    .sf-nav a:hover, .sf-nav button:hover { 
      background: rgba(0,0,0,0.5); color: rgba(255,255,255,0.8);
      border-color: rgba(255,255,255,0.3);
    }
    /* Modal */
    .sf-modal { 
      position: fixed; inset: 0; background: rgba(0,0,0,0.9); z-index: 2000;
      display: none; align-items: center; justify-content: center; padding: 20px;
    }
    .sf-modal.open { display: flex; }
    .sf-modal-content {
      background: #111; border: 1px solid #333; border-radius: 12px;
      max-width: 500px; width: 100%; max-height: 80vh; overflow-y: auto;
      padding: 30px; color: #ddd; font-family: system-ui, sans-serif;
    }
    .sf-modal h2 { margin: 0 0 20px; font-weight: 400; font-size: 24px; color: #fff; }
    .sf-modal h3 { margin: 20px 0 8px; font-weight: 500; font-size: 12px; 
      text-transform: uppercase; letter-spacing: 1px; color: #888; }
    .sf-modal p { margin: 0; line-height: 1.6; font-size: 15px; color: #aaa; }
    .sf-modal-close { 
      position: absolute; top: 20px; right: 20px; background: none; border: none;
      color: #666; font-size: 24px; cursor: pointer; padding: 10px;
    }
    .sf-modal-close:hover { color: #fff; }

  </style>
</head>
<body>

  <!-- Navigation -->
  <nav class="sf-nav">
    <a href="/" title="Back to gallery">←</a>
    <button onclick="document.getElementById('sf-modal').classList.add('open')" title="About this piece">?</button>
  </nav>
  
  <!-- Info Modal -->
  <div id="sf-modal" class="sf-modal" onclick="if(event.target===this)this.classList.remove('open')">
    <button class="sf-modal-close" onclick="document.getElementById('sf-modal').classList.remove('open')">×</button>
    <div class="sf-modal-content">
      <h2>Mycelium</h2>
      <h3>Concept</h3>
      <p>The wood wide web. Underground networks of hyphae spread, find nutrients, fruit into mushrooms.</p>
      <h3>Interaction</h3>
      <p>Click to add nutrients. Watch the mycelium grow toward them and fruit.</p>
    </div>
  </div>

<canvas id="canvas"></canvas>
  <div class="info">The wood wide web. Click to add nutrients.</div>
  
  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    let width, height;
    const hyphae = [];
    const nutrients = [];
    const mushrooms = [];
    const pulses = [];
    
    function resize() {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
    }
    resize();
    window.addEventListener('resize', resize);
    
    // Hypha tip (growing point)
    class Hypha {
      constructor(x, y, angle, energy, parent = null) {
        this.x = x;
        this.y = y;
        this.angle = angle;
        this.energy = energy;
        this.parent = parent;
        this.path = [{x, y}];
        this.alive = true;
        this.age = 0;
        this.branched = false;
      }
      
      grow() {
        if (!this.alive || this.energy <= 0) {
          this.alive = false;
          return;
        }
        
        this.age++;
        
        // Wander
        this.angle += (Math.random() - 0.5) * 0.3;
        
        // Seek nutrients
        let closest = null;
        let closestDist = Infinity;
        for (const n of nutrients) {
          if (n.depleted) continue;
          const dx = n.x - this.x;
          const dy = n.y - this.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < closestDist && dist < 200) {
            closestDist = dist;
            closest = n;
          }
        }
        
        if (closest) {
          const dx = closest.x - this.x;
          const dy = closest.y - this.y;
          const targetAngle = Math.atan2(dy, dx);
          this.angle += Math.sin(targetAngle - this.angle) * 0.1;
          
          // Found nutrient!
          if (closestDist < 15) {
            closest.depleted = true;
            this.energy += 50;
            
            // Spawn mushroom
            mushrooms.push({
              x: closest.x,
              y: closest.y,
              growth: 0,
              maxHeight: 20 + Math.random() * 30,
              width: 8 + Math.random() * 12
            });
            
            // Send pulse back through network
            pulses.push({
              path: [...this.path],
              index: this.path.length - 1,
              speed: 2
            });
          }
        }
        
        // Move
        const speed = 0.8;
        this.x += Math.cos(this.angle) * speed;
        this.y += Math.sin(this.angle) * speed;
        this.energy -= 0.15;
        
        this.path.push({x: this.x, y: this.y});
        
        // Branch occasionally
        if (!this.branched && this.energy > 30 && Math.random() < 0.01) {
          this.branched = true;
          const branchAngle = this.angle + (Math.random() > 0.5 ? 1 : -1) * (0.5 + Math.random() * 0.5);
          hyphae.push(new Hypha(this.x, this.y, branchAngle, this.energy * 0.4, this));
          this.energy *= 0.6;
        }
        
        // Die at edges
        if (this.x < 0 || this.x > width || this.y < 0 || this.y > height) {
          this.alive = false;
        }
      }
    }
    
    // Start with several origin points
    function seed() {
      const origins = 3 + Math.floor(Math.random() * 3);
      for (let i = 0; i < origins; i++) {
        const x = width * 0.2 + Math.random() * width * 0.6;
        const y = height * 0.3 + Math.random() * height * 0.4;
        const numHyphae = 4 + Math.floor(Math.random() * 4);
        
        for (let j = 0; j < numHyphae; j++) {
          const angle = (j / numHyphae) * Math.PI * 2 + Math.random() * 0.5;
          hyphae.push(new Hypha(x, y, angle, 80 + Math.random() * 40));
        }
      }
      
      // Initial nutrients
      for (let i = 0; i < 8; i++) {
        nutrients.push({
          x: Math.random() * width,
          y: Math.random() * height,
          size: 5 + Math.random() * 10,
          depleted: false
        });
      }
    }
    
    // Click to add nutrient
    canvas.addEventListener('click', (e) => {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      
      nutrients.push({
        x: e.clientX * scaleX,
        y: e.clientY * scaleY,
        size: 12 + Math.random() * 10,
        depleted: false,
        fresh: true
      });
    });
    
    function draw() {
      // Dark earth background
      ctx.fillStyle = '#1a1612';
      ctx.fillRect(0, 0, width, height);
      
      // Soil texture (subtle noise)
      ctx.fillStyle = 'rgba(30, 25, 20, 0.5)';
      for (let i = 0; i < 100; i++) {
        const x = Math.random() * width;
        const y = Math.random() * height;
        ctx.beginPath();
        ctx.arc(x, y, Math.random() * 3, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Draw nutrients
      for (const n of nutrients) {
        if (n.depleted) continue;
        
        // Fresh nutrients pulse brighter
        const freshBoost = n.fresh ? 1.5 : 1;
        if (n.fresh) n.fresh = false; // Only flash once
        
        const gradient = ctx.createRadialGradient(n.x, n.y, 0, n.x, n.y, n.size * freshBoost);
        gradient.addColorStop(0, `rgba(220, 180, 100, ${0.9 * freshBoost})`);
        gradient.addColorStop(0.4, 'rgba(180, 140, 80, 0.7)');
        gradient.addColorStop(0.7, 'rgba(140, 100, 50, 0.4)');
        gradient.addColorStop(1, 'rgba(100, 70, 30, 0)');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(n.x, n.y, n.size * freshBoost, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Grow and draw hyphae
      const activeHyphae = hyphae.filter(h => h.alive);
      
      // Occasionally spawn new hyphae if network is dying
      if (activeHyphae.length < 3 && Math.random() < 0.02) {
        const x = Math.random() * width;
        const y = Math.random() * height;
        hyphae.push(new Hypha(x, y, Math.random() * Math.PI * 2, 60 + Math.random() * 30));
      }
      
      // Occasionally add nutrients
      if (Math.random() < 0.005) {
        nutrients.push({
          x: Math.random() * width,
          y: Math.random() * height,
          size: 5 + Math.random() * 10,
          depleted: false
        });
      }
      
      for (const h of activeHyphae) {
        h.grow();
      }
      
      // Draw all hypha paths
      for (const h of hyphae) {
        if (h.path.length < 2) continue;
        
        ctx.strokeStyle = 'rgba(245, 240, 230, 0.15)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(h.path[0].x, h.path[0].y);
        
        for (let i = 1; i < h.path.length; i++) {
          ctx.lineTo(h.path[i].x, h.path[i].y);
        }
        ctx.stroke();
        
        // Brighter tip if alive
        if (h.alive) {
          const tip = h.path[h.path.length - 1];
          ctx.fillStyle = 'rgba(255, 250, 240, 0.6)';
          ctx.beginPath();
          ctx.arc(tip.x, tip.y, 2, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      
      // Draw pulses (nutrient flow)
      for (let i = pulses.length - 1; i >= 0; i--) {
        const p = pulses[i];
        p.index -= p.speed;
        
        if (p.index < 0) {
          pulses.splice(i, 1);
          continue;
        }
        
        const idx = Math.floor(p.index);
        if (idx < p.path.length) {
          const pos = p.path[idx];
          ctx.fillStyle = 'rgba(200, 255, 150, 0.8)';
          ctx.shadowColor = 'rgba(200, 255, 150, 0.5)';
          ctx.shadowBlur = 10;
          ctx.beginPath();
          ctx.arc(pos.x, pos.y, 3, 0, Math.PI * 2);
          ctx.fill();
          ctx.shadowBlur = 0;
        }
      }
      
      // Draw and grow mushrooms
      for (const m of mushrooms) {
        if (m.growth < 1) {
          m.growth += 0.01;
        }
        
        const h = m.maxHeight * m.growth;
        const w = m.width * m.growth;
        
        // Stem
        ctx.fillStyle = 'rgba(240, 235, 220, 0.9)';
        ctx.beginPath();
        ctx.moveTo(m.x - 3, m.y);
        ctx.lineTo(m.x - 2, m.y - h * 0.8);
        ctx.lineTo(m.x + 2, m.y - h * 0.8);
        ctx.lineTo(m.x + 3, m.y);
        ctx.closePath();
        ctx.fill();
        
        // Cap
        ctx.fillStyle = 'rgba(180, 120, 80, 0.9)';
        ctx.beginPath();
        ctx.ellipse(m.x, m.y - h * 0.8, w / 2, h * 0.3, 0, Math.PI, 0);
        ctx.fill();
        
        // Cap top
        ctx.fillStyle = 'rgba(140, 90, 60, 0.9)';
        ctx.beginPath();
        ctx.ellipse(m.x, m.y - h * 0.85, w / 2 - 2, h * 0.15, 0, 0, Math.PI * 2);
        ctx.fill();
      }
      
      requestAnimationFrame(draw);
    }
    
    seed();
    draw();
  </script>
</body>
</html>
